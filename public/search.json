[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to SYM2SIM (Symbolics to Simulations)",
    "section": "",
    "text": "I am interessted in a numerical framework that can solve systems of the form\n\\[\n\\partial_t \\mathbf{Q} + \\partial_{x_i} \\mathbf{F}_i = NC_i \\partial_{x_i} \\mathbf{Q} + \\mathbf{S}\n\\]\nwhere \\(\\mathbf{F}\\) is a flux, \\(NC\\) is a non-conservative matrix, \\(\\mathbf{S}\\) is a source term and dimension \\(i=[1]\\) for 1d, \\(i=[1,2]\\) for 2d and \\(i = [1, 2,3]\\) for 3d.\nI have the following design thoughts on the solver\n\nsymbolic model description for the PDE (including boundary conditions) using sympy. This will in turn allow for the following features\n\nsymbolic computation of jacobians (flux, source), eigenvalues, …\nsolver backend can be swapped between C, python, … due to sympy’s code generation feature\n\npre and postprocessing based on python\n\ngmsh compatible\nhdf5 as intermediate format\nvtk conversion\n\npyvista for vtk plotting in jupyter notebooks\n\n\nnumerics based on path-conservative 1st and 2nd order schemes for unstructured meshes\n\nhowever, it should always be possible to ‘hack’ a 1d python solver for fast development\n\ncompute intense parts can be solves via\n\npython solver (numpy for CPU, jax for GPU)\nsimple C solver on CPU/CPU using KOKKOS\nparallel C solver using PETSc (both CPU and GPU)\n\nsimple ipywidgets based GUI that runs in jupyter-notebooks. Automatic generation of GUI-elements based on tags defined in the docstrings\n\n\n\nLoad packages\nimport os\nimport numpy as np\nimport pyvista as pv\nimport matplotlib.pyplot as plt\nfrom scipy.interpolate import griddata\nfrom copy import deepcopy\nimport seaborn \nseaborn.set_context('talk')\nfrom IPython.display import Math\n\nmain_dir = os.getenv(\"SMS\")\nimport pytest\nfrom types import SimpleNamespace\n\nfrom library.model.model import *\nfrom library.pysolver.solver import *\nfrom library.pysolver.solver import jax_fvm_unsteady_semidiscrete as fvm_unsteady\nimport library.model.initial_conditions as IC\nimport library.model.boundary_conditions as BC\nfrom library.pysolver.ode import RK1\nimport library.misc.io as io\nfrom library.pysolver.reconstruction import GradientMesh\nimport library.mesh.mesh as petscMesh\nimport library.postprocessing.postprocessing as postprocessing"
  },
  {
    "objectID": "index.html#aim",
    "href": "index.html#aim",
    "title": "Introduction to SYM2SIM (Symbolics to Simulations)",
    "section": "",
    "text": "I am interessted in a numerical framework that can solve systems of the form\n\\[\n\\partial_t \\mathbf{Q} + \\partial_{x_i} \\mathbf{F}_i = NC_i \\partial_{x_i} \\mathbf{Q} + \\mathbf{S}\n\\]\nwhere \\(\\mathbf{F}\\) is a flux, \\(NC\\) is a non-conservative matrix, \\(\\mathbf{S}\\) is a source term and dimension \\(i=[1]\\) for 1d, \\(i=[1,2]\\) for 2d and \\(i = [1, 2,3]\\) for 3d.\nI have the following design thoughts on the solver\n\nsymbolic model description for the PDE (including boundary conditions) using sympy. This will in turn allow for the following features\n\nsymbolic computation of jacobians (flux, source), eigenvalues, …\nsolver backend can be swapped between C, python, … due to sympy’s code generation feature\n\npre and postprocessing based on python\n\ngmsh compatible\nhdf5 as intermediate format\nvtk conversion\n\npyvista for vtk plotting in jupyter notebooks\n\n\nnumerics based on path-conservative 1st and 2nd order schemes for unstructured meshes\n\nhowever, it should always be possible to ‘hack’ a 1d python solver for fast development\n\ncompute intense parts can be solves via\n\npython solver (numpy for CPU, jax for GPU)\nsimple C solver on CPU/CPU using KOKKOS\nparallel C solver using PETSc (both CPU and GPU)\n\nsimple ipywidgets based GUI that runs in jupyter-notebooks. Automatic generation of GUI-elements based on tags defined in the docstrings\n\n\n\nLoad packages\nimport os\nimport numpy as np\nimport pyvista as pv\nimport matplotlib.pyplot as plt\nfrom scipy.interpolate import griddata\nfrom copy import deepcopy\nimport seaborn \nseaborn.set_context('talk')\nfrom IPython.display import Math\n\nmain_dir = os.getenv(\"SMS\")\nimport pytest\nfrom types import SimpleNamespace\n\nfrom library.model.model import *\nfrom library.pysolver.solver import *\nfrom library.pysolver.solver import jax_fvm_unsteady_semidiscrete as fvm_unsteady\nimport library.model.initial_conditions as IC\nimport library.model.boundary_conditions as BC\nfrom library.pysolver.ode import RK1\nimport library.misc.io as io\nfrom library.pysolver.reconstruction import GradientMesh\nimport library.mesh.mesh as petscMesh\nimport library.postprocessing.postprocessing as postprocessing"
  },
  {
    "objectID": "index.html#example-1-2d-swe",
    "href": "index.html#example-1-2d-swe",
    "title": "Introduction to SYM2SIM (Symbolics to Simulations)",
    "section": "Example 1: 2d SWE",
    "text": "Example 1: 2d SWE\n\nMesh\n\n# mesh = petscMesh.Mesh.from_gmsh(os.path.join(main_dir, \"meshes/triangle_2d/mesh_finest.msh\"))\nmesh = petscMesh.Mesh.from_gmsh(os.path.join(main_dir, \"meshes/quad_2d/mesh_finest.msh\"))\nprint(f\"physical tags in gmsh file: {mesh.boundary_conditions_sorted_names}\")\n\n\nphysical tags in gmsh file: ['right' 'left' 'bottom' 'top']\n\n\n\n\nModel\n\nbcs = BC.BoundaryConditions(\n    [\n        BC.Periodic(physical_tag='left', periodic_to_physical_tag='right'),\n        BC.Periodic(physical_tag=\"right\", periodic_to_physical_tag='left'),\n        BC.Periodic(physical_tag='top', periodic_to_physical_tag='bottom'),\n        BC.Periodic(physical_tag=\"bottom\", periodic_to_physical_tag='top'),\n    ]\n)\n\n\ndef custom_ic(x):\n    Q = np.zeros(3, dtype=float)\n    Q[0] = np.where(x[0]**2 + x[1]**2 &lt; 0.1, 2., 1.)\n    return Q\n\nic = IC.UserFunction(custom_ic)\n\n\nmodel = ShallowWater2d(\n    boundary_conditions=bcs,\n    initial_conditions=ic,\n    settings={\"friction\": [\"chezy\"]},\n    parameters = {\"C\": 1.0, \"g\": 9.81, \"ez\": 1.0}\n)\n\n\n\nSince we are using symbolic math currently, we have access to all the nice featues of sympy. We can for instance, analytically compute * The Jacobian of the flux/source * Compute the quasilinear matrix based on the definition of a flux function and nonconservative term * Compute the analytical eigenvalues of the problem\nLet’s have a look at the symbolic components of our problem, where\n\\[\n\\begin{align*}\n& Q_i: \\text{state vector} \\\\\n& n_i: \\text{normal components} \\\\\n& g, C: \\text{parameters}\n\\end{align*}\n\\]\n\n\n\n\n\n\nNote\n\n\n\nThere might apprear \\(10^{-20}\\) expressions in the following functions. These are only present for python-based solver backends, since a constant (e.g. 0 or 1) cannot be converted to vectorizable expression, which needed for a decent runtime for python code. For C-based solver backends, this workaround is not needed.\n\n\n\n\nAutomatic tex generation\n\n\nDisplay Model\ndisplay(Math(r'\\large{' + 'Flux \\, in \\, x' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model.sympy_flux[0])) + '}'))\ndisplay(Math(r'\\large{' + 'Nonconservative \\, matrix \\, in \\, x' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model.sympy_nonconservative_matrix[0])) + '}'))\ndisplay(Math(r'\\large{' + 'Eigenvalues' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model.sympy_eigenvalues)) + '}'))\ndisplay(Math(r'\\large{' + 'Source' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model.sympy_source)) + '}'))\n\n\n\\(\\displaystyle \\large{Flux \\, in \\, x}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}q_{1}\\\\\\frac{\\frac{ez g q_{0}^{3}}{2} + q_{1}^{2}}{q_{0}}\\\\\\frac{q_{1} q_{2}}{q_{0}}\\end{matrix}\\right]}\\)\n\n\n\\(\\displaystyle \\large{Nonconservative \\, matrix \\, in \\, x}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}0 & 0 & 0\\\\0 & 0 & 0\\\\0 & 0 & 0\\end{matrix}\\right]}\\)\n\n\n\\(\\displaystyle \\large{Eigenvalues}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}\\frac{n_{0} q_{1} + n_{1} q_{2}}{q_{0}}\\\\\\frac{n_{0} q_{0} q_{1} + n_{1} q_{0} q_{2} + \\sqrt{ez g q_{0}^{5}} \\sqrt{n_{0}^{2} + n_{1}^{2}}}{q_{0}^{2}}\\\\\\frac{n_{0} q_{0} q_{1} + n_{1} q_{0} q_{2} - \\sqrt{ez g q_{0}^{5}} \\sqrt{n_{0}^{2} + n_{1}^{2}}}{q_{0}^{2}}\\end{matrix}\\right]}\\)\n\n\n\\(\\displaystyle \\large{Source}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}0\\\\- \\frac{1.0 q_{1} \\sqrt{q_{1}^{2} + q_{2}^{2}}}{C^{2} q_{0} \\left|{q_{0}}\\right|}\\\\- \\frac{1.0 q_{2} \\sqrt{q_{1}^{2} + q_{2}^{2}}}{C^{2} q_{0} \\left|{q_{0}}\\right|}\\end{matrix}\\right]}\\)\n\n\n\n\nSimulation\n\nsettings = Settings(\n    reconstruction=recon.constant,\n    num_flux=flux.LLF(),\n    nc_flux=nonconservative_flux.segmentpath(1),\n    compute_dt=timestepping.adaptive(CFL=.45),\n    time_end=1.,\n    output_snapshots=100,\n    output_clean_dir=True,\n    output_dir=\"outputs/output_introduction/swe\",\n)\n\n\nfvm_unsteady(\n    mesh, model, settings, ode_solver_source=RK1\n)\n\n\n\nPostprocessing\n\n\nPostprocessing\nio.generate_vtk(os.path.join(os.path.join(main_dir, settings.output_dir), f'{settings.name}.h5'))\nout_0 = pv.read(os.path.join(os.path.join(main_dir, settings.output_dir), 'out.0.vtk'))\nout_10 = pv.read(os.path.join(os.path.join(main_dir, settings.output_dir), 'out.10.vtk'))\nout_98 = pv.read(os.path.join(os.path.join(main_dir, settings.output_dir), 'out.98.vtk'))\nfield_names = out_0.cell_data.keys()\nprint(f'Field names: {field_names}')\n\n\nField names: ['0', '1', '2']\n\n\n\n\nPlot VTK\np = pv.Plotter(shape=(1,3), notebook=True)\n\np.subplot(0, 0)\np.add_mesh(out_0, scalars='0', show_edges=False, scalar_bar_args={'title': 'h(t=0)'})\np.enable_parallel_projection()\np.enable_image_style()\np.view_xy()\n\np.subplot(0, 1)\np.add_mesh(out_10, scalars='0', show_edges=False, scalar_bar_args={'title': 'h(t=0.1)'})\np.enable_parallel_projection()\np.enable_image_style()\np.view_xy()\n\np.subplot(0, 2)\np.add_mesh(out_98, scalars='0', show_edges=False, scalar_bar_args={'title': 'h(t=1)'})\np.enable_parallel_projection()\np.enable_image_style()\np.view_xy()\n\np.show(jupyter_backend='static')"
  },
  {
    "objectID": "index.html#example-2-2d-shallow-moments",
    "href": "index.html#example-2-2d-shallow-moments",
    "title": "Introduction to SYM2SIM (Symbolics to Simulations)",
    "section": "Example 2: 2d Shallow Moments",
    "text": "Example 2: 2d Shallow Moments\n\nMesh\n\n\nRead GMSH mesh\nmesh = petscMesh.Mesh.from_gmsh(os.path.join(main_dir, \"meshes/quad_2d/mesh_finest.msh\"))\nprint(f\"physical tags in gmsh file: {mesh.boundary_conditions_sorted_names}\")\n\n\n\nphysical tags in gmsh file: ['right' 'left' 'bottom' 'top']\n\n\n\n\nModel\n\nlevel = 1\nbcs = BC.BoundaryConditions(\n    [\n        BC.Periodic(physical_tag='left', periodic_to_physical_tag='right'),\n        BC.Periodic(physical_tag=\"right\", periodic_to_physical_tag='left'),\n        BC.Periodic(physical_tag='top', periodic_to_physical_tag='bottom'),\n        BC.Periodic(physical_tag=\"bottom\", periodic_to_physical_tag='top'),\n    ]\n)\n\ndef custom_ic_smm(x):\n    Q = np.zeros(3 + 2*level, dtype=float)\n    Q[0] = np.where(x[0]**2 + x[1]**2 &lt; 0.1, 2., 1.)\n    return Q\n\nic_smm = IC.UserFunction(custom_ic_smm)\n\nmodel_smm = ShallowMoments2d(\n    fields = 3 + 2*level,\n    boundary_conditions=bcs,\n    initial_conditions=ic_smm,\n    settings={\"friction\": [\"chezy\"]},\n    parameters = {\"C\": 1.0, \"g\": 9.81, \"ez\": 1.0},\n    basis = Basis(basis=Legendre_shifted(order=level))\n)\n\n\n\nAutomatic tex generation\n\n\nDisplay Model\ndisplay(Math(r'\\large{' + 'Flux \\, in \\, x' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model.sympy_flux[0])) + '}'))\ndisplay(Math(r'\\large{' + 'Nonconservative \\, matrix \\, in \\, x' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model.sympy_nonconservative_matrix[0])) + '}'))\ndisplay(Math(r'\\large{' + 'Eigenvalues' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model.sympy_eigenvalues)) + '}'))\ndisplay(Math(r'\\large{' + 'Source' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model.sympy_source)) + '}'))\n\n\n\\(\\displaystyle \\large{Flux \\, in \\, x}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}q_{1}\\\\\\frac{\\frac{ez g q_{0}^{3}}{2} + q_{1}^{2}}{q_{0}}\\\\\\frac{q_{1} q_{2}}{q_{0}}\\end{matrix}\\right]}\\)\n\n\n\\(\\displaystyle \\large{Nonconservative \\, matrix \\, in \\, x}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}1.0 \\cdot 10^{-20} q_{0} & 1.0 \\cdot 10^{-20} q_{0} & 1.0 \\cdot 10^{-20} q_{0}\\\\1.0 \\cdot 10^{-20} q_{0} & 1.0 \\cdot 10^{-20} q_{0} & 1.0 \\cdot 10^{-20} q_{0}\\\\1.0 \\cdot 10^{-20} q_{0} & 1.0 \\cdot 10^{-20} q_{0} & 1.0 \\cdot 10^{-20} q_{0}\\end{matrix}\\right]}\\)\n\n\n\\(\\displaystyle \\large{Eigenvalues}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}\\frac{n_{0} q_{1} + n_{1} q_{2}}{q_{0}}\\\\\\frac{n_{0} q_{0} q_{1} + n_{1} q_{0} q_{2} + \\sqrt{ez g q_{0}^{5}} \\sqrt{n_{0}^{2} + n_{1}^{2}}}{q_{0}^{2}}\\\\\\frac{n_{0} q_{0} q_{1} + n_{1} q_{0} q_{2} - \\sqrt{ez g q_{0}^{5}} \\sqrt{n_{0}^{2} + n_{1}^{2}}}{q_{0}^{2}}\\end{matrix}\\right]}\\)\n\n\n\\(\\displaystyle \\large{Source}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}1.0 \\cdot 10^{-20} q_{0}\\\\- \\frac{1.0 q_{1} \\sqrt{q_{1}^{2} + q_{2}^{2}}}{C^{2} q_{0} \\left|{q_{0}}\\right|}\\\\- \\frac{1.0 q_{2} \\sqrt{q_{1}^{2} + q_{2}^{2}}}{C^{2} q_{0} \\left|{q_{0}}\\right|}\\end{matrix}\\right]}\\)\n\n\n\n\nSimulation\n\nsettings = Settings(\n    reconstruction=recon.constant,\n    num_flux=flux.LLF(),\n    nc_flux=nonconservative_flux.segmentpath(1),\n    compute_dt=timestepping.adaptive(CFL=.45),\n    time_end=1.,\n    output_snapshots=100,\n    output_clean_dir=True,\n    output_dir=\"outputs/output_introduction/smm\",\n)\nfvm_unsteady(\n    mesh, model_smm, settings, ode_solver_source=RK1\n)\n\n\n\nPostprocessing\n\n\nPostprocessing\nio.generate_vtk(os.path.join(os.path.join(main_dir, settings.output_dir), f'{settings.name}.h5'))\nout_0 = pv.read(os.path.join(os.path.join(main_dir, settings.output_dir), 'out.0.vtk'))\nout_49 = pv.read(os.path.join(os.path.join(main_dir, settings.output_dir), 'out.10.vtk'))\nout_98 = pv.read(os.path.join(os.path.join(main_dir, settings.output_dir), 'out.98.vtk'))\nfield_names = out_0.cell_data.keys()\nprint(field_names)\n\n\n['0', '1', '2', '3', '4']\n\n\n\n\nPlot VTK\np = pv.Plotter(shape=(2,3), notebook=True)\n\np.subplot(0, 0)\np.add_mesh(out_0, scalars='0', show_edges=False, scalar_bar_args={'title': 'h(t=0)'})\np.enable_parallel_projection()\np.enable_image_style()\np.view_xy()\n\np.subplot(0, 1)\np.add_mesh(out_10, scalars='0', show_edges=False, scalar_bar_args={'title': 'h(t=0.1)'})\np.enable_parallel_projection()\np.enable_image_style()\np.view_xy()\n\np.subplot(0, 2)\np.add_mesh(out_98, scalars='0', show_edges=False, scalar_bar_args={'title': 'h(t=1)'})\np.enable_parallel_projection()\np.enable_image_style()\np.view_xy()\n\np.subplot(1, 0)\np.add_mesh(out_0.copy(), scalars='2', show_edges=False, scalar_bar_args={'title': 'lin. moment in x(t=0)'})\np.enable_parallel_projection()\np.enable_image_style()\np.view_xy()\n\np.subplot(1, 1)\np.add_mesh(out_10.copy(), scalars='2', show_edges=False, scalar_bar_args={'title': 'lin. moment in x(t=0.1)'})\np.enable_parallel_projection()\np.enable_image_style()\np.view_xy()\n\np.subplot(1, 2)\np.add_mesh(out_98.copy(), scalars='2', show_edges=False, scalar_bar_args={'title': 'lin. moment in x(t=1)'})\np.enable_parallel_projection()\np.enable_image_style()\np.view_xy()\n\np.show(jupyter_backend='static')"
  },
  {
    "objectID": "index.html#example-3-create-your-own-model",
    "href": "index.html#example-3-create-your-own-model",
    "title": "Introduction to SYM2SIM (Symbolics to Simulations)",
    "section": "Example 3: Create your own model",
    "text": "Example 3: Create your own model\n\nModel definition\n\nn_fields = 3\n#| code-fold: false\n#| code-summary: \"Construct your own model\"\nclass Euler1D(Model):\n\n    def __init__(\n        self,\n        boundary_conditions,\n        initial_conditions,\n        parameters = {},\n        settings={},\n    ):\n        super().__init__(\n            dimension=1,\n            fields=3,\n            aux_fields=0,\n            parameters=parameters,\n            boundary_conditions=boundary_conditions,\n            initial_conditions=initial_conditions,\n            # aux_initial_conditions=aux_initial_conditions,\n            settings=settings,\n        )\n\n    def get_system_variables(self):\n        Q = self.variables\n        rho = Q[0]\n        rho_u = Q[1]\n        u = rho_u / rho\n        E = Q[2]\n        e = E/rho - 1/2 * u**2\n        gamma = self.parameters.gamma\n        p =  (gamma-1)*rho*e\n        return rho, u, e, p, E, gamma\n\n\n    def flux(self):\n        flux_x = Matrix([0 for i in range(3)])\n        rho, u, e, p, E, gamma = self.get_system_variables()\n        flux_x[0] = rho * u\n        flux_x[1] = rho * u * u + p\n        flux_x[2] = E * u + p * u\n        return [flux_x]\n\n\n    def source(self):\n        assert \"C1\" in vars(self.parameters)\n        S = Matrix([0 for i in range(self.n_fields)])\n        rho, u, e, p, E, gamma = self.get_system_variables()\n        S[1] = - self.parameters.C1 * p\n        S[2] = - self.parameters.C1 * p * u\n        return S\n\n\n\nMesh and model construction\n\n\nInitialize model and mesh\nmesh = petscMesh.Mesh.create_1d((-5, 5), 100)\n\nbcs = BC.BoundaryConditions(\n    [\n        BC.Extrapolation(physical_tag='left'),\n        BC.Extrapolation(physical_tag=\"right\"),\n    ]\n)\n\nmodel_euler = Euler1D(\n    boundary_conditions = bcs,\n    initial_conditions = IC.RP(\n        high=lambda n_field: np.array([1., -0.1 , 1.]),\n        low=lambda n_field: np.array([1.,  +0.1, 1.]),\n    ),\n    parameters = {'gamma': 1.6, 'C1': 0.},\n)\n\n\n\n\nAutomatic tex generation\n\n\nDisplay model\ndisplay(Math(r'\\large{' + 'Flux \\, in \\, x' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model_euler.sympy_flux[0])) + '}'))\ndisplay(Math(r'\\large{' + 'Nonconservative \\, matrix \\, in \\, x' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model_euler.sympy_nonconservative_matrix[0])) + '}'))\ndisplay(Math(r'\\large{' + 'Eigenvalues' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model_euler.sympy_eigenvalues)) + '}'))\ndisplay(Math(r'\\large{' + 'Source' + '}'))\ndisplay(Math(r'\\large{' + sympy.latex(sympy.simplify(model_euler.sympy_source)) + '}'))\n\n\n\\(\\displaystyle \\large{Flux \\, in \\, x}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}q_{1}\\\\\\frac{q_{1}^{2} + \\left(\\gamma - 1\\right) \\left(q_{0} q_{2} - 0.5 q_{1}^{2}\\right)}{q_{0}}\\\\\\frac{q_{1} \\left(q_{0} q_{2} + \\left(\\gamma - 1\\right) \\left(q_{0} q_{2} - 0.5 q_{1}^{2}\\right)\\right)}{q_{0}^{2}}\\end{matrix}\\right]}\\)\n\n\n\\(\\displaystyle \\large{Nonconservative \\, matrix \\, in \\, x}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}0 & 0 & 0\\\\0 & 0 & 0\\\\0 & 0 & 0\\end{matrix}\\right]}\\)\n\n\n\\(\\displaystyle \\large{Eigenvalues}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}\\frac{n_{0} q_{1}}{q_{0}}\\\\\\frac{n_{0} \\left(2 q_{1} - \\sqrt{2} \\sqrt{\\gamma \\left(2 \\gamma q_{0} q_{2} - \\gamma q_{1}^{2} - 2 q_{0} q_{2} + q_{1}^{2}\\right)}\\right)}{2 q_{0}}\\\\\\frac{n_{0} \\left(2 q_{1} + \\sqrt{2} \\sqrt{\\gamma \\left(2 \\gamma q_{0} q_{2} - \\gamma q_{1}^{2} - 2 q_{0} q_{2} + q_{1}^{2}\\right)}\\right)}{2 q_{0}}\\end{matrix}\\right]}\\)\n\n\n\\(\\displaystyle \\large{Source}\\)\n\n\n\\(\\displaystyle \\large{\\left[\\begin{matrix}0\\\\- \\frac{C_{1} \\left(\\gamma - 1\\right) \\left(q_{0} q_{2} - 0.5 q_{1}^{2}\\right)}{q_{0}}\\\\- \\frac{C_{1} q_{1} \\left(\\gamma - 1\\right) \\left(q_{0} q_{2} - 0.5 q_{1}^{2}\\right)}{q_{0}^{2}}\\end{matrix}\\right]}\\)\n\n\n\n\nSimulation\n\nsettings = Settings(\n    reconstruction=recon.constant,\n    num_flux=flux.LLF(),\n    nc_flux=nonconservative_flux.segmentpath(1),\n    compute_dt=timestepping.adaptive(CFL=.9),\n    time_end=1.,\n    output_snapshots=100,\n    output_clean_dir=True,\n    output_dir=\"outputs/output_introduction/euler\",\n)\n\nfvm_unsteady(\n    mesh, model_euler, settings, ode_solver_source=RK1\n)\n\n\n\nPostprocessing\nfilepath = os.path.join(settings.output_dir, 'Simulation.h5')\nX, Q, Qaux, T = io.load_timeline_of_fields_from_hdf5(filepath)\n# remove the boundary points\nQ = Q[:, :, :-2]\nX = X[:-2]\n\n\n\n\nPostprocessing\n\nfig, ax = plt.subplots(1, 2, figsize=(12, 8))\ni_time = 0\nax[0].plot(X, Q[i_time, 0, :], label='rho')\nax[0].plot(X, Q[i_time, 1, :], label='rho u')\nax[0].plot(X, Q[i_time, 2, :], label='E')\nax[0].set_title(f'Time: {T[i_time]}')\n\ni_time = -1\nax[1].plot(X, Q[i_time, 0, :], label='rho')\nax[1].plot(X, Q[i_time, 1, :], label='rho u')\nax[1].plot(X, Q[i_time, 2, :], label='E')\nax[1].set_title(f'Time: {np.round(T[i_time], 1)}')\nplt.legend()"
  }
]