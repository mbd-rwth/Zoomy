<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme.netcdf4</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../docs/images/logo_mbd.png" alt="" class="navbar-logo">
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#support-netcdf-4-files" id="toc-support-netcdf-4-files" class="nav-link active" data-scroll-target="#support-netcdf-4-files">Support NetCDF-4 files</a>
  <ul class="collapse">
  <li><a href="#enable-netcdf-4-support" id="toc-enable-netcdf-4-support" class="nav-link" data-scroll-target="#enable-netcdf-4-support">Enable NetCDF-4 support</a></li>
  <li><a href="#accessing-netcdf-4-file" id="toc-accessing-netcdf-4-file" class="nav-link" data-scroll-target="#accessing-netcdf-4-file">Accessing NetCDF-4 file</a></li>
  <li><a href="#known-problems" id="toc-known-problems" class="nav-link" data-scroll-target="#known-problems">Known Problems</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="support-netcdf-4-files" class="level1">
<h1>Support NetCDF-4 files</h1>
<p>Starting from version 1.11.0, PnetCDF supports data access to HDF5-based NetCDF-4 files. This format is also referred as the <code>enhanced data model</code>, versus the <code>classic model</code> (in NetCDF language). The new I/O driver, called the NetCDF-4 driver, is a wrapper of the NetCDF Library that translates PnetCDF APIs to their corresponding NetCDF APIs, for example, <code>ncmpi_create</code> calls <code>nc_create</code>. Through calling PnetCDF APIs, this feature allows applications to read/write files in NetCDF-4 format.</p>
<section id="enable-netcdf-4-support" class="level2">
<h2 class="anchored" data-anchor-id="enable-netcdf-4-support">Enable NetCDF-4 support</h2>
<p>PnetCDF requires a NetCDF library that is built with parallel HDF5 capability. Example build instructions for HDF5 and NetCDF-4 are given below. * To build parallel HDF5 (version 1.10.4 or later is recommended) + Source tar ball of HDF5 can be downloaded from URL: https://www.hdfgroup.org/downloads/hdf5/source-code/ + Build commands: <code>gzip -dc hdf5-1.10.4.tar.gz | tar -xf -     cd hdf5-1.10.4     ./configure --prefix=/HDF5/install/path \                 --enable-parallel=yes \                 CC=mpicc FC=mpifort CXX=mpicxx     make install</code> * To build NetCDF-4 (version 4.6.2 or later is recommended) + Source tar ball of NetCDF-4 can be downloaded from URL: https://github.com/Unidata/netcdf-c/releases + Build commands: <code>gzip -dc v4.6.2.tar.gz | tar -xf -     cd netcdf-c-4.6.2     ./configure --prefix=/NetCDF4/install/path \                 --enable-netcdf-4 \                 CC=mpicc \                 CPPFLAGS="-I/HDF5/install/path/include" \                 LDFLAGS="-L/HDF5/install/path/lib"     make install</code> + Note NetCDF-4 library built with PnetCDF feature enabled, i.e.&nbsp;option <code>--enable-pnetcf</code>, is not supported. * To build PnetCDF with NetCDF-4 support + Add <code>--with-netcdf4</code> option at the configure command line. Option <code>--with-netcdf</code> can also be used to specify the installation path of NetCDF-4 if it is not in the standard localtions. For example, <code>gzip -dc pnetcdf-1.11.0.tar.gz | tar -xf -     cd pnetcdf-1.11.0     ./configure --prefix=/PnetCDF/install/path \                 --with-netcdf4=/NetCDF4/install/path</code></p>
</section>
<section id="accessing-netcdf-4-file" class="level2">
<h2 class="anchored" data-anchor-id="accessing-netcdf-4-file">Accessing NetCDF-4 file</h2>
<p>To create a NetCDF-4 file, add the flag NC_NETCDF4 into argument cmode when calling <code>ncmpi_create()</code>. For example,</p>
<pre><code>int cmode;
cmode = NC_CLOBBER | NC_NETCDF4;
ncmpi_create(MPI_COMM_WORLD, "testfile.nc", cmode, MPI_INFO_NULL, &amp;ncid);</code></pre>
<p>or</p>
<pre><code>cmode = NC_CLOBBER | NC_NETCDF4 | NC_CLASSIC_MODEL;
ncmpi_create(MPI_COMM_WORLD, "testfile.nc", cmode, MPI_INFO_NULL, &amp;ncid);</code></pre>
<p>NC_NETCDF4 flag is not required when opening an existing file in NetCDF-4 format, as PnetCDF checks the file format and selects the proper I/O driver.</p>
<p>Users can also set the default file format to NetCDF-4 by calling API <code>ncmpi_set_default_format()</code> with argument <code>NC_FORMAT_NETCDF4C</code> or <code>NC_FORMAT_NETCDF4_CLASSIC</code>. For example,</p>
<pre><code>ncmpi_set_default_format(NC_FORMAT_NETCDF4, &amp;old_formatp);</code></pre>
<p>or</p>
<pre><code>ncmpi_set_default_format(NC_FORMAT_NETCDF4_CLASSIC, &amp;old_formatp);</code></pre>
<p>When no file format specific flag is set in argument cmode, PnetCDF will use the default setting.</p>
</section>
<section id="known-problems" class="level2">
<h2 class="anchored" data-anchor-id="known-problems">Known Problems</h2>
<p>Some features are not supported due to the availability of APIs different between PnetCDF and NetCDF libraries. I/O semantics are also slightly different.</p>
<ul>
<li>API families of <code>vard</code>, <code>varn</code>, and nonblocking I/O are not supported. This is because NetCDF does not have corresponding APIs. Error code <code>NC_ENOTSUPPORT</code> will be returned. For vard APIs, NetCDF does not have APIs that allow accessing the file directly by an MPI derived file type. For <code>varn</code> APIs, a potential solution is to split the request into into multiple vara calls. However, such solution must deal with the situation when the numbers of requests are different among processes in the collective data mode. Supporting <code>varn</code> is thus a future work.</li>
<li>Although a new file of format NC_FORMAT_NETCDF4 or NC_FORMAT_NETCDF4_CLASSIC can be created, the I/O operations are limited to the NetCDF classic model I/O, This is because PnetCDF APIs do not include those for operating enhanced data objects, such as groups, compound data types, compression etc. As for reading a NetCDF-4 file created by NetCDF-4, PnetCDF supports the classic way of reading variables, attributes, and dimensions. Inquiry APIs for enhanced metadata is currently not supported.</li>
<li>Due to a bug in HDF5 version 1.10.2 and prior, collective I/O on record variables with a subset of participating processes making zero-length requests may cause an HDF5 error and the program to hang. Readers refer to the HDF bug issue HDFFV-10501. The bug fix will appear in HDF5 1.10.4 release.</li>
<li>PnetCDF allows different kinds of APIs called by different processes in a collective I/O. For example, <code>ncmpi_put_vara_int_all()</code> is called at process 0 and <code>ncmpi_put_vars_float_int()</code> is called at process 1. However, this is not allowed in NetCDF-4. Thus, the same kind of API must be used in a collective call when accessing a NetCDF-4 file.</li>
<li>When creating a new NetCDF-4 file, PnetCDF only allows creating 1 unlimited dimension. When reading an existing NetCDF-4 file, the file can have more than 1 unlimited dimension. However, in this case, API ncmpi_inq_unlimdim will only return the dimension ID of first unlimited dimension. This behavior conforms with NetCDF-4 library.</li>
<li>The following APIs are not supported yet. An error code NC_ENOTSUPPORT will be returned, if called.
<ul>
<li><code>ncmpi_inq_header_size</code>, <code>ncmpi_inq_header_extent</code></li>
<li><code>ncmpi_inq_striping</code></li>
<li><code>ncmpi_inq_varoffset</code></li>
<li><code>ncmpi_fill_var_rec</code></li>
<li><code>ncmpi_sync_numrecs</code></li>
<li><code>ncmpi_flush</code></li>
<li>all nonblocking APIs</li>
<li>vard and varn APIs</li>
<li>flexible APIs (i.e.&nbsp;argument buftype is a constructed MPI derived data type)</li>
</ul></li>
<li>APIs <code>ncmpi_inq_get_size</code> and <code>ncmpi_inq_put_size</code> report the amount of data that has been read or written, but excluding the I/O to the file header. They are simply the size of data passed between PnetCDF and NetCDF, not the actual size read from or written to the file system.</li>
</ul>
<p>Copyright (C) 2018, Northwestern University and Argonne National Laboratory</p>
<p>See COPYRIGHT notice in top-level directory.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Contact : <a href="mailto:correa@mbd.rwth-aachen.de"><strong>Alan Correa</strong></a>, <a href="mailto:steldermann@mbd.rwth-aachen.de"><strong>Ingo Steldermann</strong></a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><a href="https://www.mbd.rwth-aachen.de"><img src="../../../docs/images/logo_mbd.png" class="img-fluid" alt="MBD" width="200"></a></p>
</div>
  </div>
</footer>




</body></html>