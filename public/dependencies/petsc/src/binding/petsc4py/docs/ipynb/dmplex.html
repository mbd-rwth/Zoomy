<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Decoding the DMPlex</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../../../../">
<script src="../../../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../../../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../../../../docs/images/logo_mbd.png" alt="" class="navbar-logo">
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#cones-and-supports" id="toc-cones-and-supports" class="nav-link active" data-scroll-target="#cones-and-supports">Cones and Supports</a></li>
  <li><a href="#labeling" id="toc-labeling" class="nav-link" data-scroll-target="#labeling">Labeling</a></li>
  <li><a href="#meets-and-joins" id="toc-meets-and-joins" class="nav-link" data-scroll-target="#meets-and-joins">Meets and Joins</a></li>
  <li><a href="#transitive-closure" id="toc-transitive-closure" class="nav-link" data-scroll-target="#transitive-closure">Transitive Closure</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Decoding the DMPlex</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The purpose of this notebook is to provide a tutorial for the DMPlex features in PETSc. DMPlex and its sub-objects are an attempt to properly abstract out the concept of grids and the assignment of degree of freedom information to entities in that grid. The hope is that this will allow for easy implementation of different discretization ideas and subsequently lead to their fair comparison. To be able to use DMPlex you need to speak its language and understand how to get the information your methods need. In this tutorial I will explain and demonstrate the functionality of the DMPlex API.</p>
<div id="cell-2" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> __future__ <span class="im">import</span> print_function</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys,petsc4py</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>petsc4py.init(sys.argv)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> petsc4py <span class="im">import</span> PETSc</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>One way to create a DMPlex is to specify coordinates of vertices and cell connectivities. Here we encode a simple 2 by 2 element mesh of quads.</p>
<div id="cell-4" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>dim <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> np.asarray([[<span class="fl">0.0</span>, <span class="fl">0.0</span>],</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                     [<span class="fl">0.5</span>, <span class="fl">0.0</span>],</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                     [<span class="fl">1.0</span>, <span class="fl">0.0</span>],</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                     [<span class="fl">0.0</span>, <span class="fl">0.5</span>],</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>                     [<span class="fl">0.5</span>, <span class="fl">0.5</span>],</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                     [<span class="fl">1.0</span>, <span class="fl">0.5</span>],</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                     [<span class="fl">0.0</span>, <span class="fl">1.0</span>],</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                     [<span class="fl">0.5</span>, <span class="fl">1.0</span>],</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                     [<span class="fl">1.0</span>, <span class="fl">1.0</span>]])</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>cells <span class="op">=</span> np.asarray([[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">3</span>],</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">4</span>],</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">7</span>,<span class="dv">6</span>],</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">8</span>,<span class="dv">7</span>]],dtype<span class="op">=</span><span class="st">'int32'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we initialize the DMPlex using this mesh information.</p>
<div id="cell-6" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>plex <span class="op">=</span> PETSc.DMPlex().createFromCellList(dim,cells,coords)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>PETSc converts the mesh into their abstraction of a topology which they store as a Hasse Diagram. Essentially this is a list of integers which encodes all the entities of each dimension. We can use the view method to see what the DMPlex has encoded (broken, prints to the terminal but not here, capture magic doesn’t work).</p>
<div id="cell-8" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>plex.view()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The view reveals that we have a mesh in 2 dimensions and that we have 9 0-cells (vertices), 12 1-cells (edges), and 4 2-cells (quads). All mesh entities are stored as integers in a single array called a chart. Each entity in the chart is called a point. (At this point it would be good to make some kind of plot with all points numbered, I suggest sketching one.)</p>
<section id="cones-and-supports" class="level2">
<h2 class="anchored" data-anchor-id="cones-and-supports">Cones and Supports</h2>
<p>The <em>cone</em> of a point consists of the points of a dimension lower which make up that entity. So we can loop through the chart and print out each points’ cone.</p>
<div id="cell-10" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>pStart,pEnd <span class="op">=</span> plex.getChart()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(pStart,pEnd):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"point ="</span>, i, <span class="st">"</span><span class="ch">\t</span><span class="st">cone ="</span>, plex.getCone(i))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>point = 0   cone = [13 14 15 16]
point = 1   cone = [17 18 19 14]
point = 2   cone = [15 20 21 22]
point = 3   cone = [19 23 24 20]
point = 4   cone = []
point = 5   cone = []
point = 6   cone = []
point = 7   cone = []
point = 8   cone = []
point = 9   cone = []
point = 10  cone = []
point = 11  cone = []
point = 12  cone = []
point = 13  cone = [4 5]
point = 14  cone = [5 8]
point = 15  cone = [8 7]
point = 16  cone = [7 4]
point = 17  cone = [5 6]
point = 18  cone = [6 9]
point = 19  cone = [9 8]
point = 20  cone = [ 8 11]
point = 21  cone = [11 10]
point = 22  cone = [10  7]
point = 23  cone = [ 9 12]
point = 24  cone = [12 11]</code></pre>
</div>
</div>
<p>Note that the numbering is completely different from our original mesh encoding. Here we summarize what we observe from the cones of the chart entities.</p>
<ul>
<li>Points 0 through 3 correspond to quad cells. So their cones are made up of lists of 4 integers which refer to the lower dimensional entities which make up that cell–the edges.</li>
<li>Points 4 through 12 correspond to vertices. These are the lowest dimensional object we have and thus they are empty.</li>
<li>Points 13 through 24 correspond to edges. Each edge is made up of two vertices.</li>
</ul>
<p>Similarly, each point has a support. The <em>support</em> of a point is the list which consists of points of a higher dimension which contain the point in its cone. So we can now repeat the above exercise but for the support.</p>
<div id="cell-12" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(pStart,pEnd):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"point ="</span>, i, <span class="st">"</span><span class="ch">\t</span><span class="st">support ="</span>, plex.getSupport(i))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>point = 0   support = []
point = 1   support = []
point = 2   support = []
point = 3   support = []
point = 4   support = [13 16]
point = 5   support = [13 14 17]
point = 6   support = [17 18]
point = 7   support = [15 16 22]
point = 8   support = [14 15 19 20]
point = 9   support = [18 19 23]
point = 10  support = [21 22]
point = 11  support = [20 21 24]
point = 12  support = [23 24]
point = 13  support = [0]
point = 14  support = [0 1]
point = 15  support = [0 2]
point = 16  support = [0]
point = 17  support = [1]
point = 18  support = [1]
point = 19  support = [1 3]
point = 20  support = [2 3]
point = 21  support = [2]
point = 22  support = [2]
point = 23  support = [3]
point = 24  support = [3]</code></pre>
</div>
</div>
<ul>
<li>Points 0 through 3 (quads) have no support, there is nothing of higher dimension in this mesh</li>
<li>Points 4 through 12 (vertices) have at least 2 edges in their support and the middle (8) has 4 edges</li>
<li>Points 13 through 24 (edges) have at least 1 cell in their support as many as 2</li>
</ul>
<p>So the DMPlex is a dimension-independent, low memory, abstract representation of a topology which we use to represent grid objects. The DMPlex knows nothing about elements, basis functions, fluxes, degrees of freedom, etc. It is just the topology itself and is completely general. DMPlex can be used to construct any kind of topological relation. Here we created one from a cell list and then accessed its cone/support information. A DMPlex can also be built by hand using the appropriate <em>set</em> routines or with other kinds of constructors available in the API.</p>
</section>
<section id="labeling" class="level2">
<h2 class="anchored" data-anchor-id="labeling">Labeling</h2>
<p>DMPlex provides support for the labeling of points. This can be helpful if you would like to flag certain entities for some reason. By default, the DMPlex comes with a label called ‘depth’. This labels each entity based on how deep it is in the chart. You could also think of it as the dimensionality of the objects. Here we can check that the label does exist.</p>
<div id="cell-14" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(plex.getNumLabels()):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    name <span class="op">=</span> plex.getLabelName(i)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"label name = </span><span class="sc">%s</span><span class="st">"</span> <span class="op">%</span> name, <span class="st">"</span><span class="ch">\t</span><span class="st">label size = </span><span class="sc">%d</span><span class="st">"</span> <span class="op">%</span> plex.getLabelSize(name))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>label name = celltype   label size = 3
label name = depth  label size = 3</code></pre>
</div>
</div>
<p>So the label ‘depth’ does exist and we see that there are 3 different entries. Now we will loop over each item in the DMPlex and print the value of the label.</p>
<div id="cell-16" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(pStart,pEnd):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"point ="</span>,i, <span class="st">"</span><span class="ch">\t</span><span class="st">label(depth) = </span><span class="sc">%d</span><span class="st">"</span> <span class="op">%</span> plex.getLabelValue(<span class="st">"depth"</span>,i))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>point = 0   label(depth) = 2
point = 1   label(depth) = 2
point = 2   label(depth) = 2
point = 3   label(depth) = 2
point = 4   label(depth) = 0
point = 5   label(depth) = 0
point = 6   label(depth) = 0
point = 7   label(depth) = 0
point = 8   label(depth) = 0
point = 9   label(depth) = 0
point = 10  label(depth) = 0
point = 11  label(depth) = 0
point = 12  label(depth) = 0
point = 13  label(depth) = 1
point = 14  label(depth) = 1
point = 15  label(depth) = 1
point = 16  label(depth) = 1
point = 17  label(depth) = 1
point = 18  label(depth) = 1
point = 19  label(depth) = 1
point = 20  label(depth) = 1
point = 21  label(depth) = 1
point = 22  label(depth) = 1
point = 23  label(depth) = 1
point = 24  label(depth) = 1</code></pre>
</div>
</div>
<p>The depths listed match our intuition of which entities were which when we looked at the cones and support. The DMPlex has support for identifying the range of indices in the chart which correspond to each value of the depth, the so-called <em>depth stratum</em>. (I do not understand what height stratum is for yet)</p>
<div id="cell-18" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(plex.getDepth()<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"depth = </span><span class="sc">%d</span><span class="st">"</span> <span class="op">%</span> i,<span class="st">"</span><span class="ch">\t</span><span class="st">depth stratum = "</span>,plex.getDepthStratum(i),<span class="st">"</span><span class="ch">\t</span><span class="st">height stratum = "</span>,plex.getHeightStratum(i))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>depth = 0   depth stratum =  (4, 13)    height stratum =  (0, 4)
depth = 1   depth stratum =  (13, 25)   height stratum =  (13, 25)
depth = 2   depth stratum =  (0, 4)     height stratum =  (4, 13)</code></pre>
</div>
</div>
<p>We can also use labels to mark, say, boundary edges. These are the edges with only 1 entry in the support.</p>
<div id="cell-20" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>plex.createLabel(<span class="st">"boundary"</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(pStart,pEnd):</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> plex.getLabelValue(<span class="st">"depth"</span>,i) <span class="op">==</span> <span class="dv">1</span>: <span class="co"># this is an edge</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> plex.getSupportSize(i) <span class="op">==</span> <span class="dv">1</span>:    <span class="co"># only one cell has it as an edge</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>            plex.setLabelValue(<span class="st">"boundary"</span>,i,<span class="dv">1</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"point ="</span>, i, <span class="st">"</span><span class="ch">\t</span><span class="st">label(boundary) = </span><span class="sc">%d</span><span class="st">"</span> <span class="op">%</span> plex.getLabelValue(<span class="st">"boundary"</span>,i))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>point = 0   label(boundary) = -1
point = 1   label(boundary) = -1
point = 2   label(boundary) = -1
point = 3   label(boundary) = -1
point = 4   label(boundary) = -1
point = 5   label(boundary) = -1
point = 6   label(boundary) = -1
point = 7   label(boundary) = -1
point = 8   label(boundary) = -1
point = 9   label(boundary) = -1
point = 10  label(boundary) = -1
point = 11  label(boundary) = -1
point = 12  label(boundary) = -1
point = 13  label(boundary) = 1
point = 14  label(boundary) = -1
point = 15  label(boundary) = -1
point = 16  label(boundary) = 1
point = 17  label(boundary) = 1
point = 18  label(boundary) = 1
point = 19  label(boundary) = -1
point = 20  label(boundary) = -1
point = 21  label(boundary) = 1
point = 22  label(boundary) = 1
point = 23  label(boundary) = 1
point = 24  label(boundary) = 1</code></pre>
</div>
</div>
<p>The default values are set to -1 and the boundary edges were marked with a 1. Labels aren’t so useful on their own–the useful part about labeling things is that you can also get index sets of all entities with the same value of label. This means that if we wanted an index set which maps vertex numbers to the chartID we can get the PETSc IS for the ‘depth’ label for a value of 0 (again view doesn’t print here).</p>
<div id="cell-22" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>vis <span class="op">=</span> plex.getStratumIS(<span class="st">"depth"</span>,<span class="dv">0</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>vis.view()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that there are also routines which would appear to do the same as the above. However, their index sets return a local to global mapping of vertices (smallest depth in chart) and cells (largest depth in chart) useful in parallel.</p>
<div id="cell-24" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>vis <span class="op">=</span> plex.getVertexNumbering()</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>vis.view()</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>cis <span class="op">=</span> plex.getCellNumbering()</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>cis.view()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="meets-and-joins" class="level2">
<h2 class="anchored" data-anchor-id="meets-and-joins">Meets and Joins</h2>
<p>Many times in performing grid operations, you need to know how lower and/or higher dimensional items are connected to each other. In the PETSc parlance, these are called <em>meets</em> and <em>joins</em>. A <em>meet</em> of a set of points is the intersection of the points’ cones and a <em>join</em> is the intersection of the points’ support. Here we demonstrate the concept with a few examples.</p>
<div id="cell-26" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Two cells, meet is the common edge, no join</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>pnts <span class="op">=</span> [<span class="dv">0</span>,<span class="dv">1</span>]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"meet ="</span>,plex.getMeet(pnts),<span class="st">"</span><span class="ch">\t</span><span class="st">join ="</span>,plex.getJoin(pnts))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>meet = [14]     join = []</code></pre>
</div>
</div>
<div id="cell-27" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Two edges, meet is the common vertex, join is the cell to which they are both connected</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>pnts <span class="op">=</span> [<span class="dv">14</span>,<span class="dv">19</span>]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"meet ="</span>,plex.getMeet(pnts),<span class="st">"</span><span class="ch">\t</span><span class="st">join ="</span>,plex.getJoin(pnts))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>meet = [8]  join = [1]</code></pre>
</div>
</div>
<div id="cell-28" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Two vertices, no meet, join is the common edge to which they are both connected</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>pnts <span class="op">=</span> [<span class="dv">8</span>,<span class="dv">11</span>]</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"meet ="</span>,plex.getMeet(pnts),<span class="st">"</span><span class="ch">\t</span><span class="st">join ="</span>,plex.getJoin(pnts))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>meet = []   join = [20]</code></pre>
</div>
</div>
</section>
<section id="transitive-closure" class="level2">
<h2 class="anchored" data-anchor-id="transitive-closure">Transitive Closure</h2>
<p>The transitive closure of a point in the DMPlex is a list of all reachable points from the given point, by default in the ‘in-edge’ direction. The transitive closure is then a set created by recursively taking the union on all points in the cone and its cones. In other words, it is all points of lower or equal dimension that this point can “reach”. The routine also returns an array parallel to the closure array which defines how the points are oriented relative to the give point (e.g.&nbsp;for a cell, you might need to flip some edges to follow a right-handed convention). There is a flag in the routine, useCone, which if set to False will perform the same operation but in the ‘out-edge’ direction (that is, instead of recursively operating on cones, it will use the supports).</p>
<div id="cell-30" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(pStart,pEnd):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    coneclose,orient <span class="op">=</span> plex.getTransitiveClosure(i)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    suppclose,orient <span class="op">=</span> plex.getTransitiveClosure(i,useCone<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"point ="</span>,i,<span class="st">"</span><span class="ch">\t</span><span class="st">closure(cone) ="</span>,coneclose,<span class="st">"</span><span class="ch">\t</span><span class="st">closure(supp) ="</span>,suppclose)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>point = 0   closure(cone) = [ 0 13 14 15 16  4  5  8  7]    closure(supp) = [0]
point = 1   closure(cone) = [ 1 17 18 19 14  5  6  9  8]    closure(supp) = [1]
point = 2   closure(cone) = [ 2 15 20 21 22  7  8 11 10]    closure(supp) = [2]
point = 3   closure(cone) = [ 3 19 23 24 20  8  9 12 11]    closure(supp) = [3]
point = 4   closure(cone) = [4]     closure(supp) = [ 4 13 16  0]
point = 5   closure(cone) = [5]     closure(supp) = [ 5 13 14 17  0  1]
point = 6   closure(cone) = [6]     closure(supp) = [ 6 17 18  1]
point = 7   closure(cone) = [7]     closure(supp) = [ 7 15 16 22  0  2]
point = 8   closure(cone) = [8]     closure(supp) = [ 8 14 15 19 20  0  1  2  3]
point = 9   closure(cone) = [9]     closure(supp) = [ 9 18 19 23  1  3]
point = 10  closure(cone) = [10]    closure(supp) = [10 21 22  2]
point = 11  closure(cone) = [11]    closure(supp) = [11 20 21 24  2  3]
point = 12  closure(cone) = [12]    closure(supp) = [12 23 24  3]
point = 13  closure(cone) = [13  4  5]  closure(supp) = [13  0]
point = 14  closure(cone) = [14  5  8]  closure(supp) = [14  0  1]
point = 15  closure(cone) = [15  8  7]  closure(supp) = [15  0  2]
point = 16  closure(cone) = [16  7  4]  closure(supp) = [16  0]
point = 17  closure(cone) = [17  5  6]  closure(supp) = [17  1]
point = 18  closure(cone) = [18  6  9]  closure(supp) = [18  1]
point = 19  closure(cone) = [19  9  8]  closure(supp) = [19  1  3]
point = 20  closure(cone) = [20  8 11]  closure(supp) = [20  2  3]
point = 21  closure(cone) = [21 11 10]  closure(supp) = [21  2]
point = 22  closure(cone) = [22 10  7]  closure(supp) = [22  2]
point = 23  closure(cone) = [23  9 12]  closure(supp) = [23  3]
point = 24  closure(cone) = [24 12 11]  closure(supp) = [24  3]</code></pre>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Contact : <a href="mailto:correa@mbd.rwth-aachen.de"><strong>Alan Correa</strong></a>, <a href="mailto:steldermann@mbd.rwth-aachen.de"><strong>Ingo Steldermann</strong></a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><a href="https://www.mbd.rwth-aachen.de"><img src="../../../../../../../docs/images/logo_mbd.png" class="img-fluid" alt="MBD" width="200"></a></p>
</div>
  </div>
</footer>




</body></html>