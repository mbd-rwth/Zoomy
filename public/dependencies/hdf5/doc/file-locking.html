<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>file-locking</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../docs/images/logo_mbd.png" alt="" class="navbar-logo">
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#file-locking-in-hdf5" id="toc-file-locking-in-hdf5" class="nav-link active" data-scroll-target="#file-locking-in-hdf5">File Locking in HDF5</a>
  <ul class="collapse">
  <li><a href="#why-file-locks" id="toc-why-file-locks" class="nav-link" data-scroll-target="#why-file-locks">Why file locks?</a></li>
  <li><a href="#the-existing-scheme" id="toc-the-existing-scheme" class="nav-link" data-scroll-target="#the-existing-scheme">The existing scheme</a></li>
  <li><a href="#h5fstart_swmr_write" id="toc-h5fstart_swmr_write" class="nav-link" data-scroll-target="#h5fstart_swmr_write"><code>H5Fstart_swmr_write()</code></a></li>
  <li><a href="#disabling-the-locks" id="toc-disabling-the-locks" class="nav-link" data-scroll-target="#disabling-the-locks">Disabling the locks</a>
  <ul class="collapse">
  <li><a href="#configure-option" id="toc-configure-option" class="nav-link" data-scroll-target="#configure-option">Configure option</a></li>
  <li><a href="#h5pset_file_locking" id="toc-h5pset_file_locking" class="nav-link" data-scroll-target="#h5pset_file_locking"><code>H5Pset_file_locking()</code></a></li>
  <li><a href="#environment-variables" id="toc-environment-variables" class="nav-link" data-scroll-target="#environment-variables">Environment variables</a></li>
  <li><a href="#lock-disable-scheme-interactions" id="toc-lock-disable-scheme-interactions" class="nav-link" data-scroll-target="#lock-disable-scheme-interactions">Lock disable scheme interactions</a></li>
  </ul></li>
  <li><a href="#feature-matrix" id="toc-feature-matrix" class="nav-link" data-scroll-target="#feature-matrix">Feature Matrix</a></li>
  <li><a href="#appendix-file-lock-implementation" id="toc-appendix-file-lock-implementation" class="nav-link" data-scroll-target="#appendix-file-lock-implementation">Appendix: File lock implementation</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="file-locking-in-hdf5" class="level1">
<h1>File Locking in HDF5</h1>
<p>This document describes the file locking scheme that was added to HDF5 in version 1.10.0 and how you can work around it, if you choose to do so. I’ll try to keep it understandable for everyone, though diving into technical details is unavoidable, given the complexity of the material. We’re in the process of converting the HDF5 user guide (UG) to Doxygen and this document will eventually be rolled up into those files as we update things.</p>
<p><strong>Parallel HDF5 Note</strong></p>
<p>Everything written here is from the perspective of serial HDF5. When we say that you can’t access a file for write access from more than one process, we mean “from more than one independent, serial process”. Parallel HDF5 can obviously write to a file from more than one process, but that involves IPC and multiple processes working together, not independent processes with no knowledge of each other, which is what the file locks are for.</p>
<section id="why-file-locks" class="level2">
<h2 class="anchored" data-anchor-id="why-file-locks">Why file locks?</h2>
<p>The short answer is: “To prevent you from corrupting your HDF5 files and/or crashing your reader processes.”</p>
<p>The long answer is more complicated.</p>
<p>An HDF5 file’s state exists in two places when it is open for writing:</p>
<ol type="1">
<li>The HDF5 file itself</li>
<li>The HDF5 library’s various caches</li>
</ol>
<p>One of those caches is the metadata cache, which stores things like B-tree nodes that we use to locate data in the file. Problems arise when parent objects are flushed to storage before child objects. If a reader tries to load unflushed children, the object’s file offset could point at garbage and it will encounter library failures as it tries to access the non-existent objects.</p>
<p>Keep in mind that the HDF5 library is not analogous to a database server. The HDF5 library is just a simple shared library, like libjpeg. Library state is maintained per-library-instance and there is no IPC between HDF5 libraries loaded by different processes (exception: collective operations in parallel HDF5, but that’s not what were talking about here).</p>
<p>Prior to HDF5 1.10.0, concurrent access to an HDF5 file by multiple processes, when one or more processes is a writer, was not supported. There was no enforcement mechanism for this. We simply told people not to do it.</p>
<p>In HDF5 1.10.0, we updated the library to allow the single-writer / multiple-readers (SWMR - pronounced “swimmer”) access pattern. This setup allows one writer and multiple readers to access the same file, as long as a certain protocol is followed concerning file opening order and setting the right flags. Since synchronization might be tricky to pull off and the consequences of getting it wrong could result in corrupt files or crashed readers, we decided to add a file locking scheme to help users get it right. Since this would also help prevent harmful accesses when SWMR is not in use, we decided to switch the file locking scheme on by default. This scheme has been carried forward into HDF5 1.12 and 1.13 (soon to be 1.14).</p>
<p>Note that the current implementation of SWMR is only useful for appending to chunked datasets. Creating file objects like groups and datasets is not supported in the current SWMR implementation.</p>
<p>Unfortunately, this file locking scheme has caused problems for some users. This is usually people who are working on network file systems like NFS or on parallel file systems, especially when file locks have been disabled, which often causes lock calls to fail. As a result of this, we’ve added work-arounds to disable the file locking scheme over the years.</p>
</section>
<section id="the-existing-scheme" class="level2">
<h2 class="anchored" data-anchor-id="the-existing-scheme">The existing scheme</h2>
<p>There are two parts to the file locking scheme. One is the file lock itself. The second is a mark we make in the HDF5 file’s superblock. The superblock mark isn’t really that important for understanding the file locking, but since it’s entwined with the file locking scheme, we’ll cover it in the algorithm below. The lower-level details of file lock implementations are described in the appendix, but the semantics are straightforward: Locks are mandatory unless disabled, always for the entire file, and non-blocking. They are also not required for SWMR operations and simply exist to help you set up SWMR and prevent dangerous file access.</p>
<p>Here’s how it all works:</p>
<ol type="1">
<li><p>The first thing we do is check if we’re using file locks</p>
<ul>
<li>We first check the file locking property in the file access property list (fapl). The default value of this property is set at configure time when the library is built.</li>
<li>Next we check the value of the <code>HDF5_USE_FILE_LOCKING</code> environment variable, which was previously parsed at library startup. If this is set, we use the value to override the property list setting.</li>
</ul>
<p>The particulars of the ways you can disable file locks are described in a separate section below.</p>
<p>If we are not using file locking, no further file locking operations will take place.</p></li>
<li><p>We also check for ignoring file locks when they are disabled on the file system.</p>
<ul>
<li>The environment variable setting for this is checked at VFD initialization time for all library VFDs.</li>
<li>We check the value in the fapl in the <code>open</code> callback. The default value for this property was set at configure time when the library was built.</li>
</ul></li>
<li><p>When we open a file, we lock it based on the file access flags:</p>
<ul>
<li>If the <code>H5F_ACC_RDWR</code> flag is set, use an exclusive lock</li>
<li>Otherwise use a shared lock</li>
</ul>
<p>If we are ignoring disabled file locks (see below), we will silently swallow lock API call failure when locks are not implemented on the file system.</p></li>
<li><p>If the VFD supports locking and the file is open for writing, we mark the file consistency flags in the file’s superblock to indicate this.</p>
<p><strong>NOTE!</strong></p>
<ul>
<li>The VFD has to have a lock callback for this to happen. It doesn’t matter if the locking was disabled - the check is simply for the callback.</li>
<li>We mark the superblock in <strong>ANY</strong> write case - both SWMR and non-SWMR.</li>
<li>Only the latest version of the superblock is marked in this way. If you open up a file that wasn’t created with the 1.10.0 or later file format, it won’t get the superblock mark, even if it’s been opened for writing.</li>
</ul>
<p>According to the file format document and H5Fpkg.h:</p>
<ul>
<li>Bit 0 is set if the file is open for writing (<code>H5F_SUPER_WRITE_ACCESS</code>)</li>
<li>Bit 2 is set if the file is open for SWMR writing (<code>H5F_SUPER_SWMR_WRITE_ACCESS</code>)</li>
</ul>
<p>We check these superblock flags on file open and error out if they are unsuitable.</p>
<ul>
<li>If the file is already opened for non-SWMR writing, no other process can open it.</li>
<li>If the file is open for SWMR writing, only SWMR readers can open the file.</li>
<li>If you try to open a file for reading with <code>H5F_ACC_SWMR_READ</code> set and the file does not have the SWMR writer bits set in the superblock, the open call will fail.</li>
</ul>
<p>This scheme is often confused with the file locking, so it’s included here, even though it’s a bit tangential to the locks themselves.</p></li>
<li><p>If the file is open for SWMR writing (<code>H5F_ACC_SWMR_WRITE</code> is set), we remove the file lock just before the open call completes.</p></li>
<li><p>We normally don’t explicitly unlock the file on file close. We let the OS handle it when the file descriptors are closed since file locks don’t normally surivive closing the underlying file descriptor.</p></li>
</ol>
<p><strong>TL;DR</strong></p>
<p>When locks are available, HDF5 files will be exclusively locked while they are in use. The exception to this are files that are opened for SWMR writing, which are unlocked. Files that are open for any kind of writing get a “writing” superblock mark that HDF5 1.10.0+ will respect and refuse to open outside of SWMR.</p>
</section>
<section id="h5fstart_swmr_write" class="level2">
<h2 class="anchored" data-anchor-id="h5fstart_swmr_write"><code>H5Fstart_swmr_write()</code></h2>
<p>This API call can be used to switch an open file to “SWMR writing” mode as if it had been opened with the <code>H5F_ACC_SWMR_WRITE</code> flag set. This is used when code needs to perform SWMR-forbidden operations like creating groups and datasets before appending data to datasets using SWMR.</p>
<p>Most of the work of this API call involves flushing out the library caches in preparation for SWMR access, but there are a few locking operations that take place under the hood:</p>
<ul>
<li>The file’s superblock is marked as in the SWMR writer case, above.</li>
<li>For a brief period of time in the call, we convert the exclusive lock to a shared lock. It’s unclear why this was done and we’ll look into removing this.</li>
<li>At the end of the call, the lock is removed, as in the SWMR write open case described above.</li>
</ul>
</section>
<section id="disabling-the-locks" class="level2">
<h2 class="anchored" data-anchor-id="disabling-the-locks">Disabling the locks</h2>
<p>There are several ways to disable the locks, depending on which version of the HDF5 library you are working with. This section will describe the file lock disable schemes as they exist in late 2022. The current library versions at this time are 1.10.9, 1.12.3, and 1.13.2. File locks are not present in HDF5 1.8. The lock feature matrix later in this document will describe the limitations of earlier versions.</p>
<section id="configure-option" class="level3">
<h3 class="anchored" data-anchor-id="configure-option">Configure option</h3>
<p>You can set the file locking defaults at configure time. This sets the defaults for the associated properties in the fapl. Users can override the configure defaults using <code>H5Pset_file_locking()</code> or the <code>HDF5_USE_FILE_LOCKING</code> environment variable.</p>
<ul>
<li><p>Autotools</p>
<p><code>--enable-file-locking=(yes|no|best-effort)</code> sets the file locking behavior. <code>on</code> and <code>off</code> should be self-explanatory. <code>best-effort</code> turns file locking on but ignores file locks when they are disabled (default: <code>best-effort</code>).</p></li>
<li><p>CMake</p>
<ul>
<li>set <code>IGNORE_DISABLED_FILE_LOCK</code> to <code>ON</code> to ignore file locks when they are disabled on the file system (default: <code>ON</code>).</li>
<li>set <code>HDF5_USE_FILE_LOCKING</code> to <code>OFF</code> to disable file locks (default: <code>ON</code>)</li>
</ul></li>
</ul>
</section>
<section id="h5pset_file_locking" class="level3">
<h3 class="anchored" data-anchor-id="h5pset_file_locking"><code>H5Pset_file_locking()</code></h3>
<p>This API call can be used to override the configure defaults. It takes <code>hbool_t</code> parameters for both the file locking and “ignore file locks when disabled on the file system” parameters. The values set here can be overridden by the file locking environment variable.</p>
<p>There is a corresponding <code>H5Pget_file_locking()</code> call that can be used to check the currently set values of both properties in the fapl. <strong>NOTE</strong> that this call just checks the property list values. It does <strong>NOT</strong> check the environment variables!</p>
</section>
<section id="environment-variables" class="level3">
<h3 class="anchored" data-anchor-id="environment-variables">Environment variables</h3>
<p>The <code>HDF5_USE_FILE_LOCKING</code> environment variable overrides all other file locking settings.</p>
<p>HDF5 1.10.0 - No file locking environment variable</p>
<p>HDF5 1.10.1 - 1.10.6, 1.12.0: - <code>FALSE</code> turns file locking off - Anything else turns file locking on - Neither of these values ignores disabled file locks - Environment variable parsed at file create/open time</p>
<p>HDF5 1.10.7+, 1.12.1+, 1.13.x: - <code>FALSE</code> or <code>0</code> disables file locking - <code>TRUE</code> or <code>1</code> enables file locking - <code>BEST_EFFORT</code> enables file locking and ignores disabled file locks - Anything else gives you the defaults - Environment variable parsed at library startup</p>
</section>
<section id="lock-disable-scheme-interactions" class="level3">
<h3 class="anchored" data-anchor-id="lock-disable-scheme-interactions">Lock disable scheme interactions</h3>
<p>As mentioned above and reiterated here: - Configure-time settings set fapl defaults - <code>H5Pset_file_locking()</code> overrides configure-time defaults - The environment variable setting overrides all</p>
<p>If you want to check that file locking is on, you’ll need to check the fapl setting AND check the environment variable, which can override the fapl.</p>
<p><strong>!!! WARNING !!!</strong></p>
<p>Disabling the file locks is at your own risk. If more than one writer process modifies an HDF5 file at the same time, the file could be corrupted. If a reader process reads a file that is being modified by a writer, the writer process might attempt to read garbage and encounter errors or even crash.</p>
<p>In the case of:</p>
<ul>
<li>A single process accessing a file with write access</li>
<li>Any number of processes accessing a file read-only</li>
</ul>
<p>You can safely disable the file locking scheme.</p>
<p>If you are trying to set up SWMR without the benefit of the file locks, you’ll just need to be extra careful that you hold to rules for SWMR access.</p>
</section>
</section>
<section id="feature-matrix" class="level2">
<h2 class="anchored" data-anchor-id="feature-matrix">Feature Matrix</h2>
<p>The following table indicates which versions of the library support which file lock features. 1.13.0 and 1.13.1 are experimental releases (basically glorified release candidates) so they are not included here.</p>
<p><strong>Locks</strong></p>
<ul>
<li>P = POSIX locks only, Windows was a no-op that always succeeded</li>
<li>WP = POSIX and Windows locks</li>
<li>(-) = POSIX no-op lock fails</li>
<li>(+) = POSIX no-op lock passes</li>
</ul>
<p><strong>Configure Option and Environment Variable</strong></p>
<ul>
<li>on/off = sets file locks on/off</li>
<li>try = can also set “best effort”, where locks are on but ignored if disabled</li>
</ul>
<table class="table">
<colgroup>
<col style="width: 8%">
<col style="width: 11%">
<col style="width: 20%">
<col style="width: 29%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th>Version</th>
<th>Has locks</th>
<th>Configure option</th>
<th><code>H5Pset_file_locking()</code></th>
<th><code>HDF5_USE_FILE_LOCKING</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1.8.x</td>
<td>No</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="even">
<td>1.10.0</td>
<td>P(-)</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="odd">
<td>1.10.1</td>
<td>P(-)</td>
<td>-</td>
<td>-</td>
<td>on/off</td>
</tr>
<tr class="even">
<td>1.10.2</td>
<td>P(-)</td>
<td>-</td>
<td>-</td>
<td>on/off</td>
</tr>
<tr class="odd">
<td>1.10.3</td>
<td>P(-)</td>
<td>-</td>
<td>-</td>
<td>on/off</td>
</tr>
<tr class="even">
<td>1.10.4</td>
<td>P(-)</td>
<td>-</td>
<td>-</td>
<td>on/off</td>
</tr>
<tr class="odd">
<td>1.10.5</td>
<td>P(-)</td>
<td>-</td>
<td>-</td>
<td>on/off</td>
</tr>
<tr class="even">
<td>1.10.6</td>
<td>P(-)</td>
<td>-</td>
<td>-</td>
<td>on/off</td>
</tr>
<tr class="odd">
<td>1.10.7</td>
<td>P(+)</td>
<td>try</td>
<td>Y</td>
<td>try</td>
</tr>
<tr class="even">
<td>1.10.8</td>
<td>WP(+)</td>
<td>try</td>
<td>Y</td>
<td>try</td>
</tr>
<tr class="odd">
<td>1.10.9</td>
<td>WP(+)</td>
<td>try</td>
<td>Y</td>
<td>try</td>
</tr>
<tr class="even">
<td>1.12.0</td>
<td>P(-)</td>
<td>-</td>
<td>-</td>
<td>on/off</td>
</tr>
<tr class="odd">
<td>1.12.1</td>
<td>WP(+)</td>
<td>try</td>
<td>Y</td>
<td>try</td>
</tr>
<tr class="even">
<td>1.12.2</td>
<td>WP(+)</td>
<td>try</td>
<td>Y</td>
<td>try</td>
</tr>
<tr class="odd">
<td>1.13.2</td>
<td>WP(+)</td>
<td>try</td>
<td>Y</td>
<td>try</td>
</tr>
</tbody>
</table>
</section>
<section id="appendix-file-lock-implementation" class="level2">
<h2 class="anchored" data-anchor-id="appendix-file-lock-implementation">Appendix: File lock implementation</h2>
<p>The file lock system is implemented with <code>flock(2)</code> as the archetype since it has simple semantics and we don’t need range locking. Locks are advisory on many systems, but this shouldn’t be a problem for most users since the HDF5 library always respects them. If you have a program that parses or modifies HDF5 files independently of the HDF5 library, you’ll want to be mindful of any potential for concurrent access across processes.</p>
<p>On Unix systems, we call <code>flock()</code> directly when it’s available and pass <code>LOCK_SH</code> (shared lock), <code>LOCK_EX</code> (exclusive lock), and <code>LOCK_UN</code> (unlock) as described in the algorithm section. All locks are non-blocking, so we set the <code>LOCK_NB</code> flag. Sadly, <code>flock(2)</code> is not POSIX and it doesn’t lock files over NFS. We didn’t consider a lack of NFS support a problem since SWMR isn’t supported on networked file systems like NFS (write order preservation isn’t guaranteed) and <code>flock(2)</code> usually doesn’t fail when you attempt to lock NFS files.</p>
<p>On Unix systems without <code>flock(2)</code>, we implement a scheme based on <code>fcntl(2)</code> (<code>Pflock()</code> in <code>H5system.c</code>). On these systems we use <code>F_SETLK</code> (non-blocking) as the operation and set <code>l_type</code> in <code>struct flock</code> to be:</p>
<ul>
<li><code>F_UNLOCK</code> for <code>LOCK_UN</code></li>
<li><code>F_WRLOCK</code> for <code>LOCK_EX</code></li>
<li><code>F_RDLOCK</code> for <code>LOCK_SH</code></li>
</ul>
<p>We set the range to be the entire file. Most Unix-like systems have <code>flock()</code> these days, so this system probably isn’t very well tested.</p>
<p>We don’t use <code>fcntl</code>-based open file locks or mandatory locking anywhere. The former scheme is non-POSIX and the latter is deprecated.</p>
<p>On Windows, we use <code>LockFileEx()</code> and <code>UnlockFileEx()</code> to lock the entire file (<code>Wflock()</code> in <code>H5system.c</code>). We set <code>LOCKFILE_FAIL_IMMEDIATELY</code> to get non-blocking locks and set <code>LOCKFILE_EXCLUSIVE_LOCK</code> when we want an exclusive lock. SWMR isn’t well-tested on Windows, so this scheme hasn’t been as thoroughly vetted as the <code>flock</code>-based scheme.</p>
<p>On non-Windows systems where neither <code>flock(2)</code> nor <code>fcntl(2)</code> is available, we substitute a no-op stub that always succeeds (<code>Nflock()</code> in <code>H5system.c</code>). In the past, the stub always failed (see the matrix for when we made the switch). We currently know of no non-Windows systems where neither call is available so this scheme is not well-tested.</p>
<p>One thing that should be immediately apparent to anyone familiar with file locking, is that all of these schemes have subtly different semantics. We’re using file locking in a fairly crude manner, though, and lock use has always been optional, so we consider this a lower-order concern.</p>
<p>Locks are implemented at the VFD level via <code>lock</code> and <code>unlock</code> callbacks. The VFDs that implement file locks are: core (w/ backing store), direct, log, sec2, and stdio (<code>flock(2)</code> locks only). The family, multi, and splitter VFDs invoke the lock callback of their underlying sub-files. The onion and MPI-IO VFDs do NOT use locks, even though they create normal, on-disk native HDF5 files. The read-only S3 VFD and HDFS VFDs do not use file locking since they use alternative storage schemes.</p>
<p>Lock failures are detected by checking to see if <code>errno</code> is set to <code>ENOSYS</code>. This is not particularly sophisticated and was implemented as a way of working around disabled locks on popular parallel file systems.</p>
<p>One other thing to note here is that, in all of the locking schemes we use, the file locks do not survive process termination, so you don’t have to worry about files being locked forever if a process exits abnormally. If a writer crashed and the library didn’t clear the superblock mark, you can remove it with the h5clear command-line tool, which is built with the library.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Contact : <a href="mailto:correa@mbd.rwth-aachen.de"><strong>Alan Correa</strong></a>, <a href="mailto:steldermann@mbd.rwth-aachen.de"><strong>Ingo Steldermann</strong></a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><a href="https://www.mbd.rwth-aachen.de"><img src="../../../docs/images/logo_mbd.png" class="img-fluid" alt="MBD" width="200"></a></p>
</div>
  </div>
</footer>




</body></html>