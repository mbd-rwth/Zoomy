<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>tuningdesign</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../docs/images/logo_mbd.png" alt="" class="navbar-logo">
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#motivation" id="toc-motivation" class="nav-link active" data-scroll-target="#motivation">Motivation</a></li>
  <li><a href="#ideas" id="toc-ideas" class="nav-link" data-scroll-target="#ideas">Ideas</a>
  <ul class="collapse">
  <li><a href="#semantics-of-variables" id="toc-semantics-of-variables" class="nav-link" data-scroll-target="#semantics-of-variables">Semantics of Variables</a></li>
  <li><a href="#context" id="toc-context" class="nav-link" data-scroll-target="#context">Context</a></li>
  <li><a href="#intended-tool-workflow" id="toc-intended-tool-workflow" class="nav-link" data-scroll-target="#intended-tool-workflow">Intended Tool Workflow</a></li>
  </ul></li>
  <li><a href="#design" id="toc-design" class="nav-link" data-scroll-target="#design">Design</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a>
  <ul class="collapse">
  <li><a href="#tool-implementation" id="toc-tool-implementation" class="nav-link" data-scroll-target="#tool-implementation">Tool implementation</a></li>
  <li><a href="#app-implementation" id="toc-app-implementation" class="nav-link" data-scroll-target="#app-implementation">App Implementation</a></li>
  <li><a href="#kokkos-implementation" id="toc-kokkos-implementation" class="nav-link" data-scroll-target="#kokkos-implementation">Kokkos implementation</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<p>#Kokkos Tuning</p>
<p>This is a design document describing the motivation, ideas, design, and prototype implementation of the Kokkos Tuning System</p>
<section id="motivation" class="level2">
<h2 class="anchored" data-anchor-id="motivation">Motivation</h2>
<p>Currently, Kokkos makes a lot of decisions about tuning parameters (CUDA block sizes, different kernel implementations) by picking an option that results in the best performance for the widest array of applications and architectures at the time the choice is made. This approach leaves performance on the table, and appears increasingly untenable as the number of architectures and applications grows, and as software versions change.</p>
<p>The Kokkos team would like to instead open up the ability to set the parameters as part of the tooling system so that these parameters can be tuned for individual applications across all the architectures they might run on. In order to match the feel of past Kokkos tooling efforts, we’d like to achieve this with a callback system.</p>
</section>
<section id="ideas" class="level2">
<h2 class="anchored" data-anchor-id="ideas">Ideas</h2>
<p>A Kokkos Tuning system should be as small as is wise while achieving the following goals</p>
<ol type="1">
<li>Expose to tools enough data about the <em>context</em> of the running application to tune intelligently. In autotuning terms, decribe the <em>features</em></li>
<li>Expose to tools enough data about tuning parameters that they might know how to optimize what they’re asked to</li>
<li>Expose to applications an interface that they might inform a tool about their current application context</li>
<li>Expose to tools the results of their choices</li>
<li>No perturbation of Kokkos Core when this system is disabled</li>
</ol>
<p>Shared among the first three of these goals is a need for some way to describe the semantics of variables (tuning parameters, context variables) internal to Kokkos or an application to an outside tool.</p>
<section id="semantics-of-variables" class="level3">
<h3 class="anchored" data-anchor-id="semantics-of-variables">Semantics of Variables</h3>
<p>I think it’s best to talk about the semantics of variables with concrete examples.</p>
<p>Suppose Kokkos wants a tool to choose a block size for it. Suppose all the application context is perfectly understood, that the tool knows that the application has 10,000,000 particles active and that it’s running a kernel called “make_particles_go,” which is a parallel_for in the “cuda” execution space. Even with this knowledge, the tool needs to know several things about what a block size <em>is</em> for this to be generic and practical</p>
<ol type="1">
<li>Is it an integer value? A float? A string? (Type)</li>
<li>Relatedly, what are the mathematical semantics which are valid for it? Is it something for which a list can be sorted? Do the distances between items in a sorted list make sense? If I divide two values, does the ratio have some meaning? (semantics)</li>
<li>What are the valid choices for this value? Is a block size of -128 okay? How about 7? (candidates)</li>
</ol>
<p>Semantics (as always) are likely the source of the most confusion here, so a bit of detail is good. Here I’m leaning heavily on the field of statistics to enable tools to do intelligent searching. If ordering doesn’t make sense, if a value is “categorical”, the only thing a tool can do is try all possible values for a tuning value. If they’re ordered (ordinal), the search can take advantage of this by using the concept of a directional search. If the distances between elements matter (interval data) you can cheat with things like bisection. Finally if ratios matter you can play games where you increase by a factor of 10 in your searches. Note that one good point in favor of this design is that it matches up nicely with scikit-opt (a happy accident).</p>
<p>In describing the candidate values in (3), users have two options: sets or ranges. A set has a number of entries of the given type, a range has lower and upper bounds and a step size.</p>
<p>Claim: the combination of context, candidates, semantics, and types gives a tool enough to intelligently explore the search space of tuning parameters</p>
</section>
<section id="context" class="level3">
<h3 class="anchored" data-anchor-id="context">Context</h3>
<p>Suppose a tool perfectly understands what a block size is. To effectively tune one, it needs to know something about the application.</p>
<p>In a trivial case, the tool knows absolutely nothing other than candidate values for the block size, and tries to make a choice that optimizes across all invocations of kernels. This isn’t <em>that</em> far from what Kokkos does now, so it’s not unreasonable for this to produce decent results. That said, we could quickly add some context from Kokkos, stuff like the name and type of the kernel, the execution space, all with the semantic information described above. That way a tuning tool could differentiate based on all the information available to Kokkos. Going a little further, we could expose this ability to provide context to our applications. What if the tools wasn’t just tuning to the fact that the kernel name was “GEMM”, but that “matrix_size” was a million? Or that “live_particles” had a certain value? The more (relevant) context we provide to a tool, the better it will be able to tune.</p>
</section>
<section id="intended-tool-workflow" class="level3">
<h3 class="anchored" data-anchor-id="intended-tool-workflow">Intended Tool Workflow</h3>
<p>Okay, so a tool knows what it’s tuning, and it knows the context of the application well enough to do clever ML things, all of this with happy semantic information so that everything make . What should a workflow look like? A tool should</p>
<ol type="1">
<li>Listen to declarations about the semantics of context and tuning variables</li>
<li>Make tuning decisions</li>
<li>Measure their feedback</li>
<li>Get better at (2)</li>
</ol>
<p>The easier we make this loop, the better</p>
</section>
</section>
<section id="design" class="level2">
<h2 class="anchored" data-anchor-id="design">Design</h2>
<p>The design of this system is intended to reflect the above ideas with the minimal necessary additions to make the mechanics work. This section is almost entirely describing the small holes in the above descriptions. Variable declaration works exactly as described above, except that we associate types and associated values using a type_id with each type at declaration time.</p>
<p>Any time a value of a variable is declared (context) or requested (tuning), it is also associated with a context ID that says how long that declaration is valid for. So if a user sees</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>startContext<span class="op">(</span>contextId<span class="op">(</span><span class="dv">0</span><span class="op">))</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>declare_value<span class="op">(</span><span class="st">"is_safe_to_push_button"</span><span class="op">,</span><span class="kw">true</span><span class="op">,</span>contextId<span class="op">(</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>foo<span class="op">();</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>endContext<span class="op">(</span>contextId<span class="op">(</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>bar<span class="op">();</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>They should know in <code>bar</code> that it is no longer safe to push the button. Similarly, if tools have provided tuning values to contextId(0), when contextId(0) ends, that is when the tool takes measurements related to those tuning values and learns things. <em>For most tools, when they see a call to startContext associated with a contextId, they’ll do a starting measurement, and at endContext they’ll stop that measurement</em>.</p>
<p>One ugly bit of semantic complexity is in variables with complicated sets of candidates. Taking the exmaple of GPU block size, for different kernels an application might have different sets of valid block sizes. This means that while “block size” might make sense as a type, there could be different types, “block_sizes_up_to_1024,” “block_sizes_up_to_2048,” that cover the concept of block size. In our experience every solution to this problem is ugly, our alternate answers were much uglier.</p>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<p>This section describes the implementation.</p>
<p>If you’re writing a tool, you care about tool implementation.</p>
<p>If you want tools to know about information from your application, you care about application implementation</p>
<p>If you’re a Kokkos developer, you care about the application implementation and Kokkos implementation</p>
<section id="tool-implementation" class="level3">
<h3 class="anchored" data-anchor-id="tool-implementation">Tool implementation</h3>
<p>In the past, tools have responded to the <a href="https://github.com/kokkos/kokkos-tools/wiki/Profiling-Hooks">profiling hooks in Kokkos</a>. This effort adds to that, there are now a few more functions (note that I’m using the C names for types. In general you can replace Kokkos_Tools_ with Kokkos::Tools:: in C++ tools)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="dt">kokkosp_declare_output_type</span><span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> name<span class="op">,</span> <span class="at">const</span> <span class="dt">size_t</span> id<span class="op">,</span> Kokkos_Tools_VariableInfo<span class="op">&amp;</span> info<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Declares a tuning variable named <code>name</code> with uniqueId <code>id</code> and all the semantic information stored in <code>info</code>. Note that the VariableInfo struct has a <code>void*</code> field called <code>toolProvidedInfo</code>. If you fill this in, every time you get a value of that type you’ll also get back that same pointer.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="dt">kokkosp_declare_input_type</span><span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*,</span> <span class="at">const</span> <span class="dt">size_t</span><span class="op">,</span> Kokkos_Tools_VariableInfo<span class="op">&amp;</span> info<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is almost exactly like declaring a tuning variable. The only difference is that in cases where the candidate values aren’t known, <code>info.valueQuantity</code> will be set to <code>kokkos_value_unbounded</code>. This is fairly common, Kokkos can tell you that <code>kernel_name</code> is a string, but we can’t tell you what strings a user might provide.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> kokkosp_request_values<span class="op">(</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> contextId<span class="op">,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> numContextVariables<span class="op">,</span> <span class="at">const</span> Kokkos_Tools_VariableValue<span class="op">*</span> contextVariableValues<span class="op">,</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">size_t</span> numTuningVariables<span class="op">,</span> Kokkos_Tools_VariableValue<span class="op">*</span> tuningVariableValues<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here Kokkos is requesting the values of tuning variables, and most of the meat is here. The contextId tells us the scope across which these variables were used.</p>
<p>The next two arguments describe the context you’re tuning in. You have the number of context variables, and an array of that size containing their values. Note that the Kokkos_Tuning_VariableValue has a field called <code>metadata</code> containing all the info (type, semantics, and critically, candidates) about that variable.</p>
<p>The two arguments following those describe the Tuning Variables. First the number of them, then an array of that size which you can overwrite. <em>Overwriting those values is how you give values back to the application</em></p>
<p>Critically, as tuningVariableValues comes preloaded with default values, if your function body is <code>return;</code> you will not crash Kokkos, only make us use our defaults. If you don’t know, you are allowed to punt and let Kokkos do what it would.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> kokkosp_begin_context<span class="op">(</span><span class="dt">size_t</span> contextId<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This starts the context pointed at by contextId. If tools use measurements to drive tuning, this is where they’ll do their starting measurement.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> kokkosp_end_context<span class="op">(</span><span class="at">const</span> <span class="dt">size_t</span> contextId<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This simply says that the contextId in the argument is now over. If you provided tuning values associated with that context, those values can now be associated with a result.</p>
</section>
<section id="app-implementation" class="level3">
<h3 class="anchored" data-anchor-id="app-implementation">App Implementation</h3>
<p>For 99% of applications, all you need to do to interact with Kokkos Tuning Tools in your code is nothing. The only exceptions are if you want the tuning to be aware of what’s happening in your application (number of particles active, whether different physics are active) if you think that might change what the Tuning decides. If you’re feeling especially brave, you can also use the Tuning interface to tune parameters within your own application. For making people aware of your application context, you need to know about a few functions</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> Kokkos<span class="op">::</span>Tools<span class="op">::</span>Experimental<span class="op">::</span><span class="dt">declare_input_type</span><span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> variableName</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                            VariableInfo info<span class="op">,</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                            <span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This function tells a tool that you have some variable they should know about when tuning. The info describes the semantics of your variable. This is discussed in great detail under “Semantics of Variables”, but you need to say whether the values will be text, int, or float, whether they’re categorical, ordinal,interval, or ratio data, and whether the candidate values are “unbounded” (if you don’t know the full set of values), a set, or a range. This returns a <code>size_t</code> that you should store, it’s how you’ll later identify what values you’re providing or requesting from the tool. Note that this call doesn’t actually tell the tools about values, it simply tells the tool about the nature of values you’ll provide later.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> Kokkos<span class="op">::</span>Tools<span class="op">::</span>Experimental<span class="op">::</span>get_new_context_id<span class="op">();</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> Kokkos<span class="op">::</span>Tools<span class="op">::</span>Experimental<span class="op">::</span>get_current_context_id<span class="op">();</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>In this interface,
you will associate values with
"contexts" in order to decide when a given declaration of a value has gone
    out of scope.The first gets you a new context
        ID if you 're starting some new set of values. If you need to recover the last context ID so you can append to that context, rather than overwriting it with a new one, you can use `get_current_context_id()`. You' ll
            use that context id to start a context in the function</code></pre>
<p><code>c++ void Kokkos::Tools::Experimental::begin_context(size_t context_id);</code></p>
<p>This tells the tool that you’re beginning a region in which you’ll be setting and requesting values. If the tool optimizes for time, you’re telling them to start their timer.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Kokkos<span class="op">::</span>Tools<span class="op">::</span>Experimental<span class="op">::</span>set_input_values<span class="op">(</span><span class="dt">size_t</span> contextId<span class="op">,</span> <span class="dt">size_t</span> count<span class="op">,</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                                  VariableValue<span class="op">*</span> values<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here you tell tools the values for your context variables. The contextId is used to later tell when this has gone out of scope, the count is how many variables you’re declaring, and the values should come from calling <code>Kokkos::Tools::Experimental::make_variable_value</code> with the appropriate variable ID and value.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Kokkos<span class="op">::</span>Tools<span class="op">::</span>Experimental<span class="op">::</span>end_context<span class="op">(</span><span class="dt">size_t</span> contextId<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>This tells the tool that values from this context are no longer valid,
and that the tool should stop their timers.

    For those who want to declare and request tuning variables,
you only need two more functions.</code></pre>
<p><code>c++ void Kokkos::Tools::Experimental::declare_output_type(         const std::string&amp;variableName VariableInfo info);</code></p>
<pre><code>This is exactly like declareContextVariable.The only difference is that
    the
        ID's this returns should be passed to request_output_values, and that the `candidates` field in the info _must_ list valid values for the tool to provide.</code></pre>
<p><code>c++ void Kokkos::Tools::Experimental::request_output_values(                 size_t contextId, size_t count, VariableValue* values, );</code></p>
<p>Here is where you request that the tool give you a set of values. You need a contextId so that the tool can know when you’re done using the value and measure results. The count tells the tool how many variables it’s providing values for. Values is an array of your default values for that parameter, it must not crash your program if unchanged.</p>
</section>
<section id="kokkos-implementation" class="level3">
<h3 class="anchored" data-anchor-id="kokkos-implementation">Kokkos implementation</h3>
<p>In the past, Kokkos and Kokkos-tools didn’t share source code. Except for a “SpaceHandle” struct which users manually copied to their tools, nothing from Kokkos hit the tools repo, the interface consisted entirely of basic C types. If you read the ideas section, it translates to a lot of structs and enums. Despite my best efforts to minimize them, I think we now need to share some header files with kokkos-tools. Andrew Gaspar did really excellent work making this practical, we have</p>
<ol type="1">
<li>Kokkos_Profiling_C_Interface.h , which is (shockingly) a C interface that everything in Kokkos tools boils down to</li>
<li>Kokkos_Profiling_Interface.hpp, nice C++ wrappers around the C so that the C idioms don’t hit Kokkos</li>
<li>Kokkos_Profiling.[cpp/hpp], which contain things Kokkos needs to implement tooling, but the tools don’t need to know about</li>
</ol>
<p>All of our function pointer initialization and all that mess now go into Kokkos_Profiling.[cpp/hpp], all the types are in the Interface files. The interface files will be shared with kokkos/kokkos-tools.</p>
<p>In terms of build changes, we now install the above .h file, and have a KOKKOS_ENABLE_TUNING option</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Contact : <a href="mailto:correa@mbd.rwth-aachen.de"><strong>Alan Correa</strong></a>, <a href="mailto:steldermann@mbd.rwth-aachen.de"><strong>Ingo Steldermann</strong></a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><a href="https://www.mbd.rwth-aachen.de"><img src="../../../docs/images/logo_mbd.png" class="img-fluid" alt="MBD" width="200"></a></p>
</div>
  </div>
</footer>




</body></html>