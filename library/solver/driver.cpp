// TODO This needs to be auto generated by the make file!
#include "../../outputs/output_c/c_interface/Model/boundary_conditions_code.h"
#include "../../outputs/output_c/c_interface/Model/model_code.h"
// #include "../../dependencies/hdf5/c++/src/H5Cpp.h"
#include "pnetcdf.h"
#include "hdf5.h"
#include "settings.h"


#include <iostream>
#include <string>
#include <mpi.h>

// settings struct
// load settings
// load pde
// load bc
// load mesh
// load initial conditions
// bc struct
// load bc_mappings
// load_ic

void openPnetCDFFile(const std::string& filePath) {
	int ncid;
	int status = ncmpi_open(MPI_COMM_WORLD, filePath.c_str(), NC_NOWRITE, MPI_INFO_NULL, &ncid);
	if (status != NC_NOERR) {
		std::cerr << "Error opening file: " << filePath << std::endl;
	} else {
		std::cout << "File opened successfully." << std::endl;
		// Don't forget to close the file when you're done with it
		status = ncmpi_close(ncid);
		if (status != NC_NOERR) {
			std::cerr << "Error closing file: " << filePath << std::endl;
		} else {
			std::cout << "File closed successfully." << std::endl;
		}
	}
}


//TODO create a mesh class?
//TODO create a loader
void openHDF5File(const std::string& filePath) {
	hid_t file = H5Fopen(filePath.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
    if (file < 0) {
        std::cerr << "Error opening file: " << filePath << std::endl;
    } else {
        std::cout << "File opened successfully." << std::endl;

		hid_t group = H5Gopen(file, "mesh", H5P_DEFAULT);
		hid_t dataset = H5Dopen(group, "dimension", H5P_DEFAULT);
		// TODO dimension should be an attribute (small dataset)
		// TODO same applies for all small datasets (e.g. integers or strings)
		int dimension;
		H5Dread(dataset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &dimension);
		std::cout << "Dimension: " << dimension << std::endl;




        H5Fclose(file);
    }
}



int main(int argc, char** argv) {


  	// openHDF5File("../outputs/output_c/mesh.hdf5");
	// openPnetCDFFile("../outputs/output_c/mesh.nc");
	Settings settings = Settings("../outputs/output_c/settings.hdf5");

  	std::cout << "MAIN" << std::endl;

    // MPI_Init(&argc, &argv);
    // int rank;
    // MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  	// std::cout << "MAIN Parallel" << std::endl;

	// MPI_Finalize();

	// Read command line arguments 
	//  if (argc != 4){
	//   std::cerr << RERROR "The program is run as: ./nprogram inputFolder/ outputFolder/ Nthreads" << std::endl;
	// 	  return 0;
	// }

	// {
	// SERGHEI serghei;
	
	// serghei.inFolder = argv[1];
	// serghei.outFolder = argv[2];

	// serghei.par.nthreads = atoi(argv[3]);
	
	// if(!serghei.start(argc, argv)) return 0;
	// if(!serghei.compute()) return 0;
	// if(!serghei.finalise()) return 0;
  
	// } // scope guard required to ensure serghei destructor is called

	// Kokkos::finalize();
 //  MPI_Finalize();

	return 1;
}
