// TODO This needs to be auto generated by the make file!
#include "../../outputs/output_c/c_interface/Model/boundary_conditions_code.h"
#include "../../outputs/output_c/c_interface/Model/model_code.h"
// #include "../../dependencies/hdf5/c++/src/H5Cpp.h"
// #include "pnetcdf.h"
#include "hdf5.h"
#include "helpers_hdf5.h"
#include "settings.h"
#include "mesh.h"
#include "model.h"
#include "boundary_conditions.h"
#include "define.h"
#include "ode_flux.h"
#include "ode_source.h"
#include "fvm.h"
#include "timestepping.h"
#include "max_abs_eigenvalue.h"
#include "iterators.h"
#include<Kokkos_Core.hpp>
#include <petscksp.h>
#include "petscsys.h"

#include <iostream>
#include <string>
#include <mpi.h>
#include <chrono>
#include <cstdlib>

int linear_solve(const realArr2& matrix, const realArr& rhs, realArr& solution)
{
  PetscInt n = matrix.extent(0);
  Vec         sol, b; /* approx solution, RHS, exact solution */
  Mat         A;       /* linear system matrix */
  KSP         ksp;     /* linear solver context */
  PC          pc;      /* preconditioner context */
  PetscReal   norm;    /* norm of solution error */
  PetscInt    i, col[n], its;
  PetscScalar value[n];

  /*
     Create vectors
  */
  PetscCall(VecCreate(PETSC_COMM_SELF, &sol));
  PetscCall(PetscObjectSetName((PetscObject)sol, "solution"));
  PetscCall(VecSetSizes(sol, PETSC_DECIDE, n));
  PetscCall(VecSetFromOptions(sol));
  PetscCall(VecCreate(PETSC_COMM_SELF, &b));
  PetscCall(PetscObjectSetName((PetscObject)b, "rhs"));
  PetscCall(VecSetSizes(b, PETSC_DECIDE, n));
  PetscCall(VecSetFromOptions(b));

  /*
     Create matrix.
  */
  PetscCall(MatCreate(PETSC_COMM_SELF, &A));
  PetscCall(MatSetSizes(A, PETSC_DECIDE, PETSC_DECIDE, n, n));
  PetscCall(MatSetFromOptions(A));
  PetscCall(MatSetUp(A));

  /*
    Set vector 
  */
  for (i = 0; i < n; i++) {
	  PetscCall(VecSetValue(b, i, rhs(i), INSERT_VALUES));
  }
  PetscCall(VecAssemblyBegin(b));
  PetscCall(VecAssemblyEnd(b));

  /*
     Assemble matrix
  */
  for (i = 0; i < n; i++) {
  	for (int j = 0; j < n; j++) {
		PetscCall(MatSetValue(A, i, j, matrix(i,j), INSERT_VALUES));
	}
  }
  PetscCall(MatAssemblyBegin(A, MAT_FINAL_ASSEMBLY));
  PetscCall(MatAssemblyEnd(A, MAT_FINAL_ASSEMBLY));


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                Create the linear solver and set various options
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  PetscCall(KSPCreate(PETSC_COMM_SELF, &ksp));

  /*
     Set operators. Here the matrix that defines the linear system
     also serves as the matrix that defines the preconditioner.
  */
  PetscCall(KSPSetOperators(ksp, A, A));

  /*
     Set linear solver defaults for this problem (optional).
     - By extracting the KSP and PC contexts from the KSP context,
       we can then directly call any KSP and PC routines to set
       various options.
     - The following four statements are optional; all of these
       parameters could alternatively be specified at runtime via
       KSPSetFromOptions();
  */
  PetscCall(KSPGetPC(ksp, &pc));
  PetscCall(PCSetType(pc, PCJACOBI));
  PetscCall(KSPSetTolerances(ksp, 1.e-5, PETSC_DEFAULT, PETSC_DEFAULT, PETSC_DEFAULT));

  /*
    Set runtime options, e.g.,
        -ksp_type <type> -pc_type <type> -ksp_monitor -ksp_rtol <rtol>
    These options will override those specified above as long as
    KSPSetFromOptions() is called _after_ any other customization
    routines.
  */
  PetscCall(KSPSetFromOptions(ksp));

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                      Solve the linear system
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  PetscCall(KSPSolve(ksp, b, sol));

  PetscCall(KSPGetIterationNumber(ksp, &its));
  PetscCall(PetscPrintf(PETSC_COMM_SELF, "Iterations %" PetscInt_FMT "\n", its));

//   /* check that KSP automatically handles the fact that the the new non-zero values in the matrix are propagated to the KSP solver */
//   PetscCall(MatShift(A, 2.0));
//   PetscCall(KSPSolve(ksp, b, x));

  /*
	Copy the values back to the solution array
  */

  for (i = 0; i < n; i++) {
	  VecGetValues(sol, 1, &i, &solution[i]);
  }

  /*
     Free work space.  All PETSc objects should be destroyed when they
     are no longer needed.
  */
  PetscCall(KSPDestroy(&ksp));
  PetscCall(VecDestroy(&b));
  PetscCall(VecDestroy(&sol));
  PetscCall(MatDestroy(&A));
  return 0;
}

int linear_solve_test(int n)
{
  Vec         x, b, u; /* approx solution, RHS, exact solution */
  Mat         A;       /* linear system matrix */
  KSP         ksp;     /* linear solver context */
  PC          pc;      /* preconditioner context */
  PetscReal   norm;    /* norm of solution error */
  PetscInt    i, col[3], its;
  PetscScalar value[3];

  /*
     Create vectors.  Note that we form 1 vector from scratch and
     then duplicate as needed.
  */
  PetscCall(VecCreate(PETSC_COMM_SELF, &x));
  PetscCall(PetscObjectSetName((PetscObject)x, "Solution"));
  PetscCall(VecSetSizes(x, PETSC_DECIDE, n));
  PetscCall(VecSetFromOptions(x));
  PetscCall(VecDuplicate(x, &b));
  PetscCall(VecDuplicate(x, &u));

  /*
     Create matrix.  When using MatCreate(), the matrix format can
     be specified at runtime.

     Performance tuning note:  For problems of substantial size,
     preallocation of matrix memory is crucial for attaining good
     performance. See the matrix chapter of the users manual for details.
  */
  PetscCall(MatCreate(PETSC_COMM_SELF, &A));
  PetscCall(MatSetSizes(A, PETSC_DECIDE, PETSC_DECIDE, n, n));
  PetscCall(MatSetFromOptions(A));
  PetscCall(MatSetUp(A));

  /*
     Assemble matrix
  */
  value[0] = -1.0;
  value[1] = 2.0;
  value[2] = -1.0;
  for (i = 1; i < n - 1; i++) {
    col[0] = i - 1;
    col[1] = i;
    col[2] = i + 1;
    PetscCall(MatSetValues(A, 1, &i, 3, col, value, INSERT_VALUES));
  }
  i      = n - 1;
  col[0] = n - 2;
  col[1] = n - 1;
  PetscCall(MatSetValues(A, 1, &i, 2, col, value, INSERT_VALUES));
  i        = 0;
  col[0]   = 0;
  col[1]   = 1;
  value[0] = 2.0;
  value[1] = -1.0;
  PetscCall(MatSetValues(A, 1, &i, 2, col, value, INSERT_VALUES));
  PetscCall(MatAssemblyBegin(A, MAT_FINAL_ASSEMBLY));
  PetscCall(MatAssemblyEnd(A, MAT_FINAL_ASSEMBLY));

  /*
     Set exact solution; then compute right-hand-side vector.
  */
  PetscCall(VecSet(u, 1.0));
  PetscCall(MatMult(A, u, b));

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                Create the linear solver and set various options
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  PetscCall(KSPCreate(PETSC_COMM_SELF, &ksp));

  /*
     Set operators. Here the matrix that defines the linear system
     also serves as the matrix that defines the preconditioner.
  */
  PetscCall(KSPSetOperators(ksp, A, A));

  /*
     Set linear solver defaults for this problem (optional).
     - By extracting the KSP and PC contexts from the KSP context,
       we can then directly call any KSP and PC routines to set
       various options.
     - The following four statements are optional; all of these
       parameters could alternatively be specified at runtime via
       KSPSetFromOptions();
  */
  PetscCall(KSPGetPC(ksp, &pc));
  PetscCall(PCSetType(pc, PCJACOBI));
  PetscCall(KSPSetTolerances(ksp, 1.e-5, PETSC_DEFAULT, PETSC_DEFAULT, PETSC_DEFAULT));

  /*
    Set runtime options, e.g.,
        -ksp_type <type> -pc_type <type> -ksp_monitor -ksp_rtol <rtol>
    These options will override those specified above as long as
    KSPSetFromOptions() is called _after_ any other customization
    routines.
  */
  PetscCall(KSPSetFromOptions(ksp));

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                      Solve the linear system
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  PetscCall(KSPSolve(ksp, b, x));

  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                      Check the solution and clean up
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
  PetscCall(VecAXPY(x, -1.0, u));
  PetscCall(VecNorm(x, NORM_2, &norm));
  PetscCall(KSPGetIterationNumber(ksp, &its));
  PetscCall(PetscPrintf(PETSC_COMM_SELF, "Norm of error %g, Iterations %" PetscInt_FMT "\n", (double)norm, its));

  /* check that KSP automatically handles the fact that the the new non-zero values in the matrix are propagated to the KSP solver */
  PetscCall(MatShift(A, 2.0));
  PetscCall(KSPSolve(ksp, b, x));

  /*
     Free work space.  All PETSc objects should be destroyed when they
     are no longer needed.
  */
  PetscCall(KSPDestroy(&ksp));

  PetscCall(VecDestroy(&x));
  PetscCall(VecDestroy(&u));
  PetscCall(VecDestroy(&b));
  PetscCall(MatDestroy(&A));
  return 0;
}

int main(int argc, char **argv)
{
	auto start_main = std::chrono::high_resolution_clock::now();
	// read make parameters
	const int dimension = DIMENSION;
	const int n_boundary_conditions = N_BOUNDARY_CONDITIONS;	
	const int n_elements = N_ELEMENTS;
	const int n_fields = N_FIELDS;
	const int n_fields_aux = N_FIELDS_AUX;
	const std::string path_settings = PATH_SETTINGS;
	const std::string path_mesh = PATH_MESH;
	const std::string path_fields = PATH_FIELDS;
	const std::string timestepper_type = TIMESTEPPER;
	const double timestepper_param = TIMESTEPPER_PARAM;

	const char* env_n_threads = std::getenv("OMP_N_THREADS");
	int n_threads = 1; // Default value
	if (env_n_threads) {
	    try {
	        n_threads = std::stoi(env_n_threads);
	    } catch (std::invalid_argument& e) {
	        std::cout << "Invalid value for OMP_N_THREADS, using default value 1" << std::endl;
	    }
	} else {
	    std::cout << "OMP_N_THREADS not set, using default value 1" << std::endl;
	}

	PetscInt n = 10;
	PetscMPIInt size;

	PetscFunctionBeginUser;
  	PetscCall(PetscInitialize(&argc, &argv, (char *)0, ""));
  	PetscCallMPI(MPI_Comm_size(PETSC_COMM_WORLD, &size));
  	PetscCheck(size == 1, PETSC_COMM_WORLD, PETSC_ERR_WRONG_MPI_SIZE, "This is a uniprocessor example only!");
  	PetscCall(PetscOptionsGetInt(NULL, NULL, "-n", &n, NULL));


	Kokkos::Timer timer;
	double time_start = timer.seconds();
  	Kokkos::InitializationSettings kokkosSettings;
	if(n_threads!=0) kokkosSettings.set_num_threads(n_threads);

	Kokkos::initialize(kokkosSettings);
	{
		std::cout << "C program running" << std::endl;

		// INITIALIZE arrays
		realArr2 Q("Q", n_fields, n_elements);
		realArr2 Qaux("Qaux", n_fields_aux, n_elements);
		Settings settings = Settings(path_settings);
		realArr parameters = settings.parameters;
		const Mesh mesh = Mesh(path_mesh);
		hid_t file_fields = openHdf5(path_fields, "r+");
		double time = loadFieldFromHdf5(file_fields, 0, Q, Qaux);
		Model model = Model();
		const auto boundary_conditions = BoundaryConditions();
		intArr2 element_neighbor_index_iteration_list = create_neighbor_index_iteration_list(mesh);

		TimeStepper* timestepper = get_timestepper(timestepper_type, timestepper_param, mesh, model);

		double max_abs_ev;

        const int n_snapshots = 100;
		double dt_print_interval = settings.time_end / (double)n_snapshots;
		double dt_print_next = dt_print_interval;
		// Integrator integrator_space = Integrator(ode_space);
		// Integrator integrator_source = Integrator(ode_source);
		FluxSolutionOperator FSO = FluxSolutionOperator(model, boundary_conditions, mesh, element_neighbor_index_iteration_list, "fvm_semidiscrete_split_step");
		SourceSolutionOperator SSO = SourceSolutionOperator(model);


		realArr2 A("Q", 2, 2);
		realArr b("b", 2);
		realArr x("x", 2);
		A(0, 0) = 2.0;
		A(1, 1) = 2.0;
		b(0) = 1.0;
		b(1) = 1.0;
		std::cout << "--------------------------------" << std::endl;
		std::cout << "--------------------------------" << std::endl;
		std::cout << "--------------------------------" << std::endl;
		int err = linear_solve(A, b, x);
		std::cout << "x: " << x(0) << " " << x(1) << std::endl;
		std::cout << "--------------------------------" << std::endl;
		std::cout << "--------------------------------" << std::endl;
		std::cout << "--------------------------------" << std::endl;

		double dt;
		int iteration;

		// settings.time_end = 2.0;
		// RUN
		auto start_loop = std::chrono::high_resolution_clock::now();
		while (time < settings.time_end)
		{
			max_abs_ev = max_abs_eigenvalue(Q, Qaux, parameters, element_neighbor_index_iteration_list, model, mesh);

			dt = timestepper->get_dt(max_abs_ev);
			if (time + dt * 1.01 > settings.time_end)
				dt = settings.time_end - time;

			FLUX_INTEGRATOR(FSO, Q, Qaux, parameters, dt, Q);
			SSO.evaluate(Q, Qaux, parameters, dt, Q);
			// integrator_space.evaluate(space_solution_operator, Q, Qaux, parameters, dt, Q);
			// integrator_source.evaluate(source_solution_operator, Q, Qaux, parameters, dt, Q);

			std::cout << "iteration: " << iteration << " time: " << time << " dt: " << dt << std::endl;

			iteration++;
			time += dt;
			if (time > dt_print_next)
			{
				saveFieldToHdf5(file_fields, iteration, time, Q, Qaux);
				dt_print_next += dt_print_interval;
			}
		}

		// int iteration = 1;
		// time += 1.;
		// saveFieldToHdf5(file_fields, iteration, time, Q, Qaux);

		H5Fclose(file_fields);
		delete timestepper;
		auto end = std::chrono::high_resolution_clock::now();
		std::chrono::duration<double> diff_loop = end-start_loop;
		std::cout << "Loop time: " << diff_loop.count() << " s\n";
	}
	double time_end = timer.seconds();
	std::cout << "Time elapsed: " << time_end - time_start << std::endl;
	Kokkos::finalize();
	auto end = std::chrono::high_resolution_clock::now();
	std::chrono::duration<double> diff_main = end-start_main;
	std::cout << "Total time: " << diff_main.count() << " s\n";
  	PetscCall(PetscFinalize());
	return 0;
}
