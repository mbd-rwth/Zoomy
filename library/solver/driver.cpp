// TODO This needs to be auto generated by the make file!
#include "../../outputs/output_c/c_interface/Model/boundary_conditions_code.h"
#include "../../outputs/output_c/c_interface/Model/model_code.h"
// #include "../../dependencies/hdf5/c++/src/H5Cpp.h"
// #include "pnetcdf.h"
#include "hdf5.h"
#include "settings.h"
#include "mesh.h"
// #include "model.h"
#include "boundary_conditions.h"
// #include "containers.h"
// #include "SArray.h"
#include "define.h"
#include<Kokkos_Core.hpp>

#include <iostream>
#include <string>
#include <mpi.h>

// [x] settings struct
// [x] load settings
// [x] load mesh
// [x] load initial conditions
// [ ] load pde
// [ ] load bc
// [x] bc-mesh struct
// [x] load bc_mesh_mappings

int main(int argc, char **argv)
{
	Kokkos::initialize();
	{
		Settings settings = Settings("../outputs/output_c/settings.hdf5");
		Mesh mesh = Mesh("../outputs/output_c/mesh.hdf5");
		realArr2 Q;
		realArr2 Qaux;

		const int N = 3;
		const int M = 4;
		const int D = 2;
		realArr q = realArr("q", 3);
		realArr2 q2 = realArr2("q2", 3, 2);
		realArr3 q3 = realArr3("q3", N, M, D);

		double * q3_ptr = q3.data();
		for (int i = 0; i < N * M * D; ++i)
		{
			std::cout << q3_ptr[i] << std::endl;
		}

		for (int d = 0; d < D; ++d)
		{
			for (int j = 0; j < M; ++j)
			{
				for (int i = 0; i < N; ++i)
				{
					std::cout << "q3[" << i << "]["<< j << "]["  << d << "]:"  << q3(i, j, d) << std::endl;
				}
			}
		}

		double time = 0.;
		hid_t file_fields = openHdf5("../outputs/output_c/fields.hdf5");
		time = loadFieldFromHdf5(file_fields, 0, Q, Qaux);
		// Qaux can be empty. However, I still need to iterate over it in the code, because I do not want to guard it with an if statement.
		// Therefore I reference it to Q. This also probibites me to use Qaux directly, rather I need to take a pointer to it.
		// if (!Qaux.empty())
		// {
		// 	std::cout << "Qaux is not empty" << std::endl;
		// 	Qaux_ptr = &Qaux;
		// }
		// else
		// {
		// 	std::cout << "Qaux is empty" << std::endl;
		// 	Qaux_ptr = &Q;
		// }
		H5Fclose(file_fields);

		const int dim = 2;
		// Model<dim> model;
		std::vector<std::vector<double>> F(dim, std::vector<double>(3));
		std::vector<std::vector<std::vector<double>>> dFdQ(dim, std::vector<std::vector<double>>(3, std::vector<double>(3)));
		// model.flux(Q[0], (*Qaux_ptr)[0], settings.parameters, F);
		// model.flux(Q[0], Qaux[0], settings.parameters, F);
		// model.quasilinear_matrix(Q[0], Qaux[0], settings.parameters, dFdQ);
		// for (int i = 0; i < dim; ++i)
		// {
		// 	for (int j = 0; j < 3; ++j)
		// 	{
		// 		std::cout << "F[" << i << "][" << j << "]: " << F[i][j] << std::endl;
		// 			for (int k = 0; k < 3; ++k)
		// 			{
		// 				std::cout << "dFdQ[" << i << "][" << j << "]: " << "[" << k << "]: " << dFdQ[i][j][k] << std::endl;
		// 			}
		// 	}
		// }
		std::cout << "MAIN" << std::endl;

		// MPI_Init(&argc, &argv);
		// int rank;
		// MPI_Comm_rank(MPI_COMM_WORLD, &rank);

		// std::cout << "MAIN Parallel" << std::endl;


		// Read command line arguments
		//  if (argc != 4){
		//   std::cerr << RERROR "The program is run as: ./nprogram inputFolder/ outputFolder/ Nthreads" << std::endl;
		// 	  return 0;
		// }

		// {
		// SERGHEI serghei;

		// serghei.inFolder = argv[1];
		// serghei.outFolder = argv[2];

		// serghei.par.nthreads = atoi(argv[3]);

		// if(!serghei.start(argc, argv)) return 0;
		// if(!serghei.compute()) return 0;
		// if(!serghei.finalise()) return 0;

		// } // scope guard required to ensure serghei destructor is called

		// Kokkos::finalize();
		//  MPI_Finalize();
	}
	Kokkos::finalize();
	return 0;
}
