// TODO This needs to be auto generated by the make file!
#include "../../outputs/output_c/c_interface/Model/boundary_conditions_code.h"
#include "../../outputs/output_c/c_interface/Model/model_code.h"
// #include "../../dependencies/hdf5/c++/src/H5Cpp.h"
// #include "pnetcdf.h"
#include "hdf5.h"
#include "helpers_hdf5.h"
#include "settings.h"
#include "mesh.h"
#include "model.h"
#include "boundary_conditions.h"
#include "define.h"
#include "ode_flux.h"
#include "ode_source.h"
#include "fvm.h"
#include "timestepping.h"
#include "misc.h"
#include "max_abs_eigenvalue.h"
#include "iterators.h"
#include "callbacks.h"
#include<Kokkos_Core.hpp>
#include <petscksp.h>

#include <iostream>
#include <string>
#include <mpi.h>
#include <chrono>
#include <cstdlib>


int main(int argc, char **argv)
{
	auto start_main = std::chrono::high_resolution_clock::now();
	// read make parameters
	const int dimension = DIMENSION;
	const int n_boundary_conditions = N_BOUNDARY_CONDITIONS;	
	const int n_elements = N_ELEMENTS;
	const int n_fields = N_FIELDS;
	const int n_fields_aux = N_FIELDS_AUX;
	const std::string path_settings = PATH_SETTINGS;
	const std::string path_mesh = PATH_MESH;
	const std::string path_fields = PATH_FIELDS;
	const std::string timestepper_type = TIMESTEPPER;
	const double timestepper_param = TIMESTEPPER_PARAM;

	const char* env_n_threads = std::getenv("OMP_N_THREADS");
	int n_threads = 1; // Default value
	if (env_n_threads) {
	    try {
	        n_threads = std::stoi(env_n_threads);
	    } catch (std::invalid_argument& e) {
	        std::cout << "Invalid value for OMP_N_THREADS, using default value 1" << std::endl;
	    }
	} else {
	    std::cout << "OMP_N_THREADS not set, using default value 1" << std::endl;
	}

	// PetscInt n = 10;
	PetscMPIInt size;

	PetscFunctionBeginUser;
  	PetscCall(PetscInitialize(&argc, &argv, (char *)0, ""));
  	PetscCallMPI(MPI_Comm_size(PETSC_COMM_WORLD, &size));
  	PetscCheck(size == 1, PETSC_COMM_WORLD, PETSC_ERR_WRONG_MPI_SIZE, "This is a uniprocessor example only!");
  	// PetscCall(PetscOptionsGetInt(NULL, NULL, "-n", &n, NULL));


	Kokkos::Timer timer;
	double time_start = timer.seconds();
  	Kokkos::InitializationSettings kokkosSettings;
	if(n_threads!=0) kokkosSettings.set_num_threads(n_threads);

	Kokkos::initialize(kokkosSettings);
	{
		std::cout << "C program running" << std::endl;

		// INITIALIZE arrays
		realArr2 Q("Q", n_elements, n_fields);
		realArr2 Qaux("Qaux", n_elements, n_fields_aux);
		Settings settings = Settings(path_settings);
		realArr parameters = settings.parameters;
		const Mesh mesh = Mesh(path_mesh);
		hid_t file_fields = openHdf5(path_fields, "r+");
		double time = loadFieldFromHdf5(file_fields, 0, Q, Qaux);
		realArr2 Qold = realArr2("Qold", Q.extent(0), Q.extent(1));
		realArr2 Qauxold = realArr2("Qauxold", Qaux.extent(0), Qaux.extent(1));
		Model model = Model();
		const auto boundary_conditions = BoundaryConditions();
		intArr2 element_neighbor_index_iteration_list = create_neighbor_index_iteration_list(mesh);

		TimeStepper* timestepper = get_timestepper(timestepper_type, timestepper_param, mesh, model);
		int max_iteration = 99999;

		double max_abs_ev;

        const int n_snapshots = 10;
		double dt_print_interval = settings.time_end / (double)n_snapshots;
		double dt_print_next = dt_print_interval;
		FluxSolutionOperator FSO = FluxSolutionOperator(model, boundary_conditions, mesh, element_neighbor_index_iteration_list, "fvm_semidiscrete_split_step");
		SourceSolutionOperator SSO = SourceSolutionOperator(model);

		double dt;
		int iteration = 0;

		Callbacks callbacks;
		callbacks.register_callbacks(settings.callbacks);
		callbacks.call_init(settings, mesh, model, boundary_conditions, Q, Qaux, parameters, max_abs_ev, time, dt, iteration);

		// RUN
		auto start_loop = std::chrono::high_resolution_clock::now();
		while (time < settings.time_end && iteration < max_iteration)
		{
			Qold = realArr2(Q);
			Qauxold = realArr2(Qaux);
			max_abs_ev = max_abs_eigenvalue(Q, Qaux, parameters, element_neighbor_index_iteration_list, model, mesh);

			dt = timestepper->get_dt(max_abs_ev);
			if (time + dt * 1.01 > settings.time_end)
				dt = settings.time_end - time;

			callbacks.call_loop(settings, mesh, model, boundary_conditions, Qold, Qauxold, parameters, max_abs_ev, time, dt, iteration);

			FLUX_INTEGRATOR(FSO, Qold, Qauxold, parameters, dt, Q);
			SSO.evaluate(Q, Qaux, parameters, dt, Q);


			iteration++;
			time += dt;
			if (time > dt_print_next)
			{
				saveFieldToHdf5(file_fields, iteration, time, Q, Qaux);
				dt_print_next += dt_print_interval;
			}
		}

		H5Fclose(file_fields);
		delete timestepper;
		auto end = std::chrono::high_resolution_clock::now();
		std::chrono::duration<double> diff_loop = end-start_loop;
		std::cout << "Loop time: " << diff_loop.count() << " s\n";
		callbacks.call_close(settings, mesh, model, boundary_conditions, Q, Qaux, parameters, max_abs_ev, time, dt, iteration);
	}
	double time_end = timer.seconds();
	std::cout << "Time elapsed: " << time_end - time_start << std::endl;
	Kokkos::finalize();
	auto end = std::chrono::high_resolution_clock::now();
	std::chrono::duration<double> diff_main = end-start_main;
	std::cout << "Total time: " << diff_main.count() << " s\n";
  	PetscCall(PetscFinalize());
	return 0;
}
