// TODO This needs to be auto generated by the make file!
#include "../../outputs/output_c/c_interface/Model/boundary_conditions_code.h"
#include "../../outputs/output_c/c_interface/Model/model_code.h"
// #include "../../dependencies/hdf5/c++/src/H5Cpp.h"
// #include "pnetcdf.h"
#include "hdf5.h"
#include "helpers_hdf5.h"
#include "settings.h"
#include "mesh.h"
#include "model.h"
#include "boundary_conditions.h"
#include "define.h"
#include "ode.h"
#include "space_solution_operator.h"
#include "timestepping.h"
#include "max_abs_eigenvalue.h"
#include "iterators.h"
#include<Kokkos_Core.hpp>

#include <iostream>
#include <string>
#include <mpi.h>


int main(int argc, char **argv)
{
	// read make parameters
	const int dimension = DIMENSION;
	const int n_boundary_conditions = N_BOUNDARY_CONDITIONS;	
	const int n_elements = N_ELEMENTS;
	const int n_fields = N_FIELDS;
	const int n_fields_aux = N_FIELDS_AUX;
	const int n_threads = N_THREADS;
	const std::string path_settings = PATH_SETTINGS;
	const std::string path_mesh = PATH_MESH;
	const std::string path_fields = PATH_FIELDS;
	
	Kokkos::Timer timer;
	double time_start = timer.seconds();
  	Kokkos::InitializationSettings kokkosSettings;
	if(n_threads!=0) kokkosSettings.set_num_threads(n_threads);

	Kokkos::initialize(kokkosSettings);
	{
		std::cout << "C program running" << std::endl;

		// INITIALIZE arrays
		realArr2 Q("Q", n_fields, n_elements);
		realArr2 Qaux("Qaux", n_fields_aux, n_elements);
		Settings settings = Settings(path_settings);
		realArr parameters = settings.parameters;
		Mesh mesh = Mesh(path_mesh);
		hid_t file_fields = openHdf5(path_fields, "r+");
		double time = loadFieldFromHdf5(file_fields, 0, Q, Qaux);
		Model model = Model();
		auto boundary_conditions = BoundaryConditions();
		intArr2 element_neighbor_index_iteration_list = create_neighbor_index_iteration_list(mesh);

		TimeStepper* timestepper = new Constant(0.0005);

		int iteration = 0;
		double dt;
		double max_abs_ev;

		double dt_print_interval = settings.time_end / 50;
		double dt_print_next = dt_print_interval;

		SpaceSolutionOperator space_solution_operator = SpaceSolutionOperator(model, boundary_conditions, mesh, element_neighbor_index_iteration_list, "fvm_semidiscrete_split_step");
		SourceSolutionOperator source_solution_operator = SourceSolutionOperator(model);

		Integrator integrator_space = Integrator("RK1");
		Integrator integrator_source = Integrator("RK1");

		// settings.time_end = 2.0;
		// RUN
		while (time < settings.time_end)
		{
			max_abs_ev = max_abs_eigenvalue(Q, Qaux, parameters, element_neighbor_index_iteration_list, model, mesh);

			dt = timestepper->get_dt(max_abs_ev);
			if (time + dt * 1.01 > settings.time_end)
				dt = settings.time_end - time;

			integrator_space.evaluate(space_solution_operator, Q, Qaux, parameters, dt, Q);
			integrator_source.evaluate(source_solution_operator, Q, Qaux, parameters, dt, Q);

			std::cout << "iteration: " << iteration << " time: " << time << " dt: " << dt << std::endl;

			iteration++;
			time += dt;
			if (time > dt_print_next)
			{
				saveFieldToHdf5(file_fields, iteration, time, Q, Qaux);
				dt_print_next += dt_print_interval;
			}
		}

		// int iteration = 1;
		// time += 1.;
		// saveFieldToHdf5(file_fields, iteration, time, Q, Qaux);

		H5Fclose(file_fields);
	}
	// delete timestepper();
	double time_end = timer.seconds();
	std::cout << "Time elapsed: " << time_end - time_start << std::endl;
	Kokkos::finalize();
	return 0;
}
