// TODO This needs to be auto generated by the make file!
#include "../../outputs/output_c/c_interface/Model/boundary_conditions_code.h"
#include "../../outputs/output_c/c_interface/Model/model_code.h"
// #include "../../dependencies/hdf5/c++/src/H5Cpp.h"
// #include "pnetcdf.h"
#include "hdf5.h"
#include "settings.h"
#include "mesh.h"
#include "model.h"
#include "boundary_conditions.h"

#include <iostream>
#include <string>
#include <mpi.h>

// [x] settings struct
// [x] load settings
// [x] load mesh
// [x] load initial conditions
// [ ] load pde
// [ ] load bc
// [x] bc-mesh struct
// [x] load bc_mesh_mappings

int main(int argc, char **argv)
{
	Settings settings = Settings("../outputs/output_c/settings.hdf5");
	Mesh mesh = Mesh("../outputs/output_c/mesh.hdf5");
	std::vector<std::vector<double>> Q;
	std::vector<std::vector<double>> Qaux;
	std::vector<std::vector<double>> *Qaux_ptr = nullptr;

	double time = 0.;
	hid_t file_fields = openHdf5("../outputs/output_c/fields.hdf5");
	time = loadFieldFromHdf5(file_fields, 0, Q, Qaux);
	// Qaux can be empty. However, I still need to iterate over it in the code, because I do not want to guard it with an if statement.
	// Therefore I reference it to Q. This also probibites me to use Qaux directly, rather I need to take a pointer to it.
	if (!Qaux.empty())
	{
		Qaux_ptr = &Qaux;
	}
	else
	{
		Qaux_ptr = &Q;
	}
	H5Fclose(file_fields);

	Model<1> model;
	std::vector<std::vector<double>> F(3, std::vector<double>(3));
	// for (int i = 0; i < 3; ++i)
	// {
	// 	std::cout << "Q[" << i << "]: " << Q[0][i] << std::endl;
	// 	std::cout << "F[" << i << "]: " << F[0][i] << std::endl;
	// 	std::cout << "Q[" << i << "]: " << (*Qaux_ptr)[0].data() << std::endl;
	// }
	model.flux(Q[0], (*Qaux_ptr)[0], settings.parameters, F);
	std::cout << "flux_x: " << F[0][0] << std::endl;
	std::cout << "flux_x: " << F[0][1] << std::endl;
	std::cout << "flux_x: " << F[0][2] << std::endl;

	std::cout << "MAIN" << std::endl;

	// MPI_Init(&argc, &argv);
	// int rank;
	// MPI_Comm_rank(MPI_COMM_WORLD, &rank);

	// std::cout << "MAIN Parallel" << std::endl;

	// MPI_Finalize();

	// Read command line arguments
	//  if (argc != 4){
	//   std::cerr << RERROR "The program is run as: ./nprogram inputFolder/ outputFolder/ Nthreads" << std::endl;
	// 	  return 0;
	// }

	// {
	// SERGHEI serghei;

	// serghei.inFolder = argv[1];
	// serghei.outFolder = argv[2];

	// serghei.par.nthreads = atoi(argv[3]);

	// if(!serghei.start(argc, argv)) return 0;
	// if(!serghei.compute()) return 0;
	// if(!serghei.finalise()) return 0;

	// } // scope guard required to ensure serghei destructor is called

	// Kokkos::finalize();
	//  MPI_Finalize();

	return 1;
}
