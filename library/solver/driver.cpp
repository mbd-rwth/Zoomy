// TODO This needs to be auto generated by the make file!
#include "../../outputs/output_c/c_interface/Model/boundary_conditions_code.h"
#include "../../outputs/output_c/c_interface/Model/model_code.h"
// #include "../../dependencies/hdf5/c++/src/H5Cpp.h"
// #include "pnetcdf.h"
#include "hdf5.h"
#include "helpers_hdf5.h"
#include "settings.h"
#include "mesh.h"
#include "model.h"
#include "boundary_conditions.h"
#include "define.h"
#include "ode_flux.h"
#include "ode_source.h"
#include "fvm.h"
#include "timestepping.h"
#include "max_abs_eigenvalue.h"
#include "iterators.h"
#include<Kokkos_Core.hpp>

#include <iostream>
#include <string>
#include <mpi.h>
#include <chrono>
#include <cstdlib>


int main(int argc, char **argv)
{
	auto start_main = std::chrono::high_resolution_clock::now();
	// read make parameters
	const int dimension = DIMENSION;
	const int n_boundary_conditions = N_BOUNDARY_CONDITIONS;	
	const int n_elements = N_ELEMENTS;
	const int n_fields = N_FIELDS;
	const int n_fields_aux = N_FIELDS_AUX;
	const std::string path_settings = PATH_SETTINGS;
	const std::string path_mesh = PATH_MESH;
	const std::string path_fields = PATH_FIELDS;
	const std::string timestepper_type = TIMESTEPPER;
	const double timestepper_param = TIMESTEPPER_PARAM;

	const char* env_n_threads = std::getenv("OMP_N_THREADS");
	int n_threads = 1; // Default value
	if (env_n_threads) {
	    try {
	        n_threads = std::stoi(env_n_threads);
	    } catch (std::invalid_argument& e) {
	        std::cout << "Invalid value for OMP_N_THREADS, using default value 1" << std::endl;
	    }
	} else {
	    std::cout << "OMP_N_THREADS not set, using default value 1" << std::endl;
	}
	
	Kokkos::Timer timer;
	double time_start = timer.seconds();
  	Kokkos::InitializationSettings kokkosSettings;
	if(n_threads!=0) kokkosSettings.set_num_threads(n_threads);

	Kokkos::initialize(kokkosSettings);
	{
		std::cout << "C program running" << std::endl;

		// INITIALIZE arrays
		realArr2 Q("Q", n_fields, n_elements);
		realArr2 Qaux("Qaux", n_fields_aux, n_elements);
		Settings settings = Settings(path_settings);
		realArr parameters = settings.parameters;
		const Mesh mesh = Mesh(path_mesh);
		hid_t file_fields = openHdf5(path_fields, "r+");
		double time = loadFieldFromHdf5(file_fields, 0, Q, Qaux);
		Model model = Model();
		const auto boundary_conditions = BoundaryConditions();
		intArr2 element_neighbor_index_iteration_list = create_neighbor_index_iteration_list(mesh);

		TimeStepper* timestepper = get_timestepper(timestepper_type, timestepper_param, mesh, model);

		double max_abs_ev;

        const int n_snapshots = 100;
		double dt_print_interval = settings.time_end / (double)n_snapshots;
		double dt_print_next = dt_print_interval;
		// Integrator integrator_space = Integrator(ode_space);
		// Integrator integrator_source = Integrator(ode_source);
		FluxSolutionOperator FSO = FluxSolutionOperator(model, boundary_conditions, mesh, element_neighbor_index_iteration_list, "fvm_semidiscrete_split_step");
		SourceSolutionOperator SSO = SourceSolutionOperator(model);


		double dt;
		int iteration;

		// settings.time_end = 2.0;
		// RUN
		auto start_loop = std::chrono::high_resolution_clock::now();
		while (time < settings.time_end)
		{
			max_abs_ev = max_abs_eigenvalue(Q, Qaux, parameters, element_neighbor_index_iteration_list, model, mesh);

			dt = timestepper->get_dt(max_abs_ev);
			if (time + dt * 1.01 > settings.time_end)
				dt = settings.time_end - time;

			FLUX_INTEGRATOR(FSO, Q, Qaux, parameters, dt, Q);
			SSO.evaluate(Q, Qaux, parameters, dt, Q);
			// integrator_space.evaluate(space_solution_operator, Q, Qaux, parameters, dt, Q);
			// integrator_source.evaluate(source_solution_operator, Q, Qaux, parameters, dt, Q);

			std::cout << "iteration: " << iteration << " time: " << time << " dt: " << dt << std::endl;

			iteration++;
			time += dt;
			if (time > dt_print_next)
			{
				saveFieldToHdf5(file_fields, iteration, time, Q, Qaux);
				dt_print_next += dt_print_interval;
			}
		}

		// int iteration = 1;
		// time += 1.;
		// saveFieldToHdf5(file_fields, iteration, time, Q, Qaux);

		H5Fclose(file_fields);
		delete timestepper;
		auto end = std::chrono::high_resolution_clock::now();
		std::chrono::duration<double> diff_loop = end-start_loop;
		std::cout << "Loop time: " << diff_loop.count() << " s\n";
	}
	double time_end = timer.seconds();
	std::cout << "Time elapsed: " << time_end - time_start << std::endl;
	Kokkos::finalize();
	auto end = std::chrono::high_resolution_clock::now();
	std::chrono::duration<double> diff_main = end-start_main;
	std::cout << "Total time: " << diff_main.count() << " s\n";
	return 0;
}
