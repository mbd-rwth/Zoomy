{
  "hash": "825abaa94cc4ebe26a5d417b2cef369c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Poission Tutorial'\nauthor: Ingo Steldermann\ndate: 07/10/2025\nformat:\n  html:\n    code-fold: false\n    code-tools: true\n    css: ../notebook.css\n---\n\n## Imports\n\n::: {#4f583c96 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Load packages\"}\nimport os\nimport numpy as np\nimport jax\nfrom jax import numpy as jnp\nimport pytest\nfrom types import SimpleNamespace\nfrom sympy import cos, pi\nfrom time import time as gettime\n\nfrom library.fvm.solver import Solver, Settings\nfrom library.fvm.ode import RK1\nimport library.fvm.reconstruction as recon\nimport library.fvm.timestepping as timestepping\nimport library.fvm.flux as flux\nimport library.fvm.nonconservative_flux as nc_flux\nfrom library.model.boundary_conditions import BoundaryCondition\nfrom library.model.models.basisfunctions import Basisfunction, Legendre_shifted\nfrom library.model.models.basismatrices import Basismatrices\n\nfrom library.model.model import *\nimport library.model.initial_conditions as IC\nimport library.model.boundary_conditions as BC\nimport library.misc.io as io\nfrom library.mesh.mesh import compute_derivatives\nfrom tests.pdesoft import plots_paper\n\n\nimport library.mesh.mesh as petscMesh\nimport library.postprocessing.postprocessing as postprocessing\nfrom library.mesh.mesh import convert_mesh_to_jax\nimport argparse\n```\n:::\n\n\n## Solver definition\n\n::: {#e3aa0717 .cell execution_count=2}\n``` {.python .cell-code}\nclass PoissonSolver(Solver):\n    def update_qaux(self, Q, Qaux, Qold, Qauxold, mesh, model, parameters, time, dt):\n        T = Q[0]\n        ddTdxx  = compute_derivatives(T, mesh, derivatives_multi_index=([[2]]))[:,0]\n        Qaux = Qaux.at[0].set(ddTdxx)\n        return Qaux\n\n\ndef solve(\n    mesh, model, settings\n):\n    solver = PoissonSolver()\n    \n    Q, Qaux = solver.initialize(model, mesh)\n\n    parameters = model.parameter_values\n\n    parameters = jnp.asarray(parameters)\n    \n    mesh = convert_mesh_to_jax(mesh)\n\n\n    pde, bcs = solver._load_runtime_model(model)\n\n    output_hdf5_path = os.path.join(settings.output_dir, f\"{settings.name}.h5\")\n    save_fields = io.get_save_fields(output_hdf5_path, settings.output_write_all)\n\n    assert model.dimension == mesh.dimension\n\n    time = 0.0\n    dt = 0.0\n    i_snapshot = 0.0\n\n    io.init_output_directory(settings.output_dir, settings.output_clean_dir)\n    mesh.write_to_hdf5(output_hdf5_path)\n    i_snapshot = save_fields(time, 0.0, i_snapshot, Q, Qaux)\n\n    Q0 = Q\n    Qnew = Q\n    Qold = Q\n    Qauxnew = Qaux\n    Qauxold = Qaux\n\n    min_inradius = jnp.min(mesh.cell_inradius)\n\n    boundary_operator = solver.get_apply_boundary_conditions(mesh, bcs)\n    \n    time_start = gettime()\n\n    Q = boundary_operator(time, Q, Qaux, parameters)\n    Qnew = solver.implicit_solve(Q, Qaux, Qold, Qauxold, mesh, model, pde, parameters, time, dt, boundary_operator, debug=[True, False])\n\n    time = 2.0\n    i_snapshot = save_fields(time, 1., i_snapshot, Qnew, Qauxnew)\n\n    time_start = gettime()\n\n    print(f\"Runtime: {gettime() - time_start}\")\n\n    return Q, Qaux\n\n```\n:::\n\n\n## Simulation\n\n::: {#9d8b0a27 .cell execution_count=3}\n``` {.python .cell-code}\nsettings = Settings(\n        name=\"Poisson\",\n        parameters={\"alpha\": 1.},\n        compute_dt=timestepping.adaptive(CFL=0.9),\n        output_snapshots=100,\n        output_dir=\"outputs/poisson\",\n        output_write_all=True\n    )\n\nbc_tags = [\"left\", \"right\"]\nbc_tags_periodic_to = [\"right\", \"left\"]\n\nbcs = BC.BoundaryConditions( [\n        BC.Lambda(physical_tag='left', prescribe_fields={0: lambda t, x, dx, q, qaux, p, n: 1.}),\n        BC.Lambda(physical_tag='right', prescribe_fields={0: lambda t, x, dx, q, qaux, p, n: 2.}),\n    ]\n)\n\ndef custom_ic(x):\n    Q = np.zeros(1, dtype=float)\n    Q[0] = 0.\n    return Q\n\nic = IC.UserFunction(custom_ic)\n\n\nmodel = Poisson(\n    parameters={\"alpha\": 1.},\n    boundary_conditions=bcs,\n    initial_conditions=ic,\n    settings={},\n)\n\nmesh = petscMesh.Mesh.create_1d((0., 1.), 300, lsq_degree = 2)\n\nQ, Qaux = solve(\n    mesh,\n    model,\n    settings,\n)\nio.generate_vtk(os.path.join(settings.output_dir, f\"{settings.name}.h5\"))\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNewton Iter 0: residual norm = 9.394e+04\nNewton Iter 1: residual norm = 1.487e-01\nNewton Iter 2: residual norm = 2.105e-07\nRuntime: 7.152557373046875e-07\n```\n:::\n:::\n\n\n::: {#a2b1acac .cell execution_count=4}\n``` {.python .cell-code}\nfig = plots_paper.plot_poisson(os.path.join(settings.output_dir, settings.name + \".h5\"))\n```\n\n::: {.cell-output .cell-output-display}\n![](simple_files/figure-html/cell-5-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "simple_files"
    ],
    "filters": [],
    "includes": {}
  }
}