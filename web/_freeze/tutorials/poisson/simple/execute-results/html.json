{
  "hash": "825abaa94cc4ebe26a5d417b2cef369c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Poission Tutorial'\nauthor: Ingo Steldermann\ndate: 07/10/2025\nformat:\n  html:\n    code-fold: false\n    code-tools: true\n    css: ../notebook.css\n---\n\n## Imports\n\n::: {#4f583c96 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Load packages\"}\nimport os\nimport numpy as np\nimport jax\nfrom jax import numpy as jnp\nimport pytest\nfrom types import SimpleNamespace\nfrom sympy import cos, pi\nfrom time import time as gettime\n\nfrom library.zoomy_core.fvm.solver import Solver, Settings\nfrom library.zoomy_core.fvm.ode import RK1\nimport library.zoomy_core.fvm.reconstruction as recon\nimport library.zoomy_core.fvm.timestepping as timestepping\nimport library.zoomy_core.fvm.flux as flux\nimport library.zoomy_core.fvm.nonconservative_flux as nc_flux\nfrom library.zoomy_core.model.boundary_conditions import BoundaryCondition\nfrom library.zoomy_core.model.models.basisfunctions import Basisfunction, Legendre_shifted\nfrom library.zoomy_core.model.models.basismatrices import Basismatrices\n\nfrom library.zoomy_core.model.model import *\nimport library.zoomy_core.model.initial_conditions as IC\nimport library.zoomy_core.model.boundary_conditions as BC\nimport library.zoomy_core.misc.io as io\nfrom library.zoomy_core.mesh.mesh import compute_derivatives\nfrom tests.pdesoft import plots_paper\n\n\nimport library.zoomy_core.mesh.mesh as petscMesh\nimport library.postprocessing.postprocessing as postprocessing\nfrom library.zoomy_core.mesh.mesh import convert_mesh_to_jax\nimport argparse\n```\n:::\n\n\n## Solver definition\n\n::: {#e3aa0717 .cell execution_count=2}\n``` {.python .cell-code}\nclass PoissonSolver(Solver):\n    def update_qaux(self, Q, Qaux, Qold, Qauxold, mesh, model, parameters, time, dt):\n        T = Q[0]\n        ddTdxx  = compute_derivatives(T, mesh, derivatives_multi_index=([[2]]))[:,0]\n        Qaux = Qaux.at[0].set(ddTdxx)\n        return Qaux\n\n\ndef solve(\n    mesh, model, settings\n):\n    solver = PoissonSolver()\n    \n    Q, Qaux = solver.initialize(model, mesh)\n\n    parameters = model.parameter_values\n\n    parameters = jnp.asarray(parameters)\n    \n    mesh = convert_mesh_to_jax(mesh)\n\n\n    pde, bcs = solver._load_runtime_model(model)\n\n    output_hdf5_path = os.path.join(settings.output_dir, f\"{settings.name}.h5\")\n    save_fields = io.get_save_fields(output_hdf5_path, settings.output_write_all)\n\n    assert model.dimension == mesh.dimension\n\n    time = 0.0\n    dt = 0.0\n    i_snapshot = 0.0\n\n    io.init_output_directory(settings.output_dir, settings.output_clean_dir)\n    mesh.write_to_hdf5(output_hdf5_path)\n    i_snapshot = save_fields(time, 0.0, i_snapshot, Q, Qaux)\n\n    Q0 = Q\n    Qnew = Q\n    Qold = Q\n    Qauxnew = Qaux\n    Qauxold = Qaux\n\n    min_inradius = jnp.min(mesh.cell_inradius)\n\n    boundary_operator = solver.get_apply_boundary_conditions(mesh, bcs)\n    \n    time_start = gettime()\n\n    Q = boundary_operator(time, Q, Qaux, parameters)\n    Qnew = solver.implicit_solve(Q, Qaux, Qold, Qauxold, mesh, model, pde, parameters, time, dt, boundary_operator, debug=[True, False])\n\n    time = 2.0\n    i_snapshot = save_fields(time, 1., i_snapshot, Qnew, Qauxnew)\n\n    time_start = gettime()\n\n    print(f\"Runtime: {gettime() - time_start}\")\n\n    return Q, Qaux\n\n```\n:::\n\n\n## Simulation\n\n::: {#9d8b0a27 .cell execution_count=3}\n``` {.python .cell-code}\nsettings = Settings(\n        name=\"Poisson\",\n        parameters={\"alpha\": 1.},\n        compute_dt=timestepping.adaptive(CFL=0.9),\n        output_snapshots=100,\n        output_dir=\"outputs/poisson\",\n        output_write_all=True\n    )\n\nbc_tags = [\"left\", \"right\"]\nbc_tags_periodic_to = [\"right\", \"left\"]\n\nbcs = BC.BoundaryConditions( [\n        BC.Lambda(tag='left', prescribe_fields={0: lambda t, x, dx, q, qaux, p, n: 1.}),\n        BC.Lambda(tag='right', prescribe_fields={0: lambda t, x, dx, q, qaux, p, n: 2.}),\n    ]\n)\n\ndef custom_ic(x):\n    Q = np.zeros(1, dtype=float)\n    Q[0] = 0.\n    return Q\n\nic = IC.UserFunction(custom_ic)\n\n\nmodel = Poisson(\n    parameters={\"alpha\": 1.},\n    boundary_conditions=bcs,\n    initial_conditions=ic,\n    settings={},\n)\n\nmesh = petscMesh.Mesh.create_1d((0., 1.), 300, lsq_degree = 2)\n\nQ, Qaux = solve(\n    mesh,\n    model,\n    settings,\n)\nio.generate_vtk(os.path.join(settings.output_dir, f\"{settings.name}.h5\"))\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNewton Iter 0: residual norm = 9.394e+04\nNewton Iter 1: residual norm = 1.487e-01\nNewton Iter 2: residual norm = 2.105e-07\nRuntime: 7.152557373046875e-07\n```\n:::\n:::\n\n\n::: {#a2b1acac .cell execution_count=4}\n``` {.python .cell-code}\nfig = plots_paper.plot_poisson(os.path.join(settings.output_dir, settings.name + \".h5\"))\n```\n\n::: {.cell-output .cell-output-display}\n![](simple_files/figure-html/cell-5-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "simple_files"
    ],
    "filters": [],
    "includes": {}
  }
}